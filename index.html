<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RicochetRobot:)</title>
    <style>
        body {
            height: 100vh; /* Full height of the viewport */
            display: flex; /* Use Flexbox for layout */
            justify-content: center; /* Center items horizontally */
            align-items: center; /* Center items vertically */
            flex-direction: column; /* Stack items vertically */
            transition: background-color 0.5s; /* Smooth background color transition */
            background-color: dimgrey; /* Set background color to dimgrey initially */
            overflow: hidden; /* Hide scrollbars */
            position: relative; /* Make body a positioning context */
        }

        .checkbox-container {
            display: flex; /* Use Flexbox for checkbox alignment */
            flex-direction: column; /* Stack checkboxes vertically */
            align-items: flex-start; /* Align checkboxes to the start */
            opacity: 0; /* Start hidden */
            pointer-events: none; /* Prevent interaction */
            transition: opacity 0.5s; /* Fade in transition */
        }
        .square {
            position: absolute;
            width: 3.125vw; /* Width of the square */
            height: 6.25vh; /* Height of the square */
            background-color: white; /* Background color */
            border-top: 0.3vh solid black; /* Default border thickness and color */
            border-bottom: 0.3vh solid black;
            border-left: 0.15vw solid black;
            border-right: 0.15vw solid black;
            box-sizing: border-box; /* Ensures padding and border are included in width/height */
        }
        .triangle {
            position: relative;
            width: 0;
            height: 0;
        }

        .triangle-border {
            position: absolute;
            width: 0;
            height: 0;
        }
        .hexagon {
            position: relative;
            width: 2vw; /* Adjust as needed */
            height: 1.2vw; /* Maintain proportions */
            background-color: transparent; /* Make background transparent */
            margin: 0; /* Remove margin to prevent extra spacing */
        }

        .hexagon::before,
        .hexagon::after {
            content: "";
            position: absolute;
            width: 1px;
            
            border-left: 1vw solid transparent; /* Half of the hexagon's width */
            border-right: 1vw solid transparent; /* Half of the hexagon's width */

        }

        .hexagon::before {
            top: -0.6vw; /* Half of the height */
            border-bottom: 0.6vw solid currentColor; /* Adjust to match height */
            border-Left : '1px solid black';
            border-Right : '1px solid black';
        }

        .hexagon::after {
            bottom: -0.6vw; /* Half of the height */
            border-top: 0.6vw solid currentColor; /* Adjust to match height */
            border-Left : '1px solid black';
            border-Right : '1px solid black';
        }

        /* New class for hexagon border */
        .hexagon-border {
            border: 1px solid black; /* Black border */
            background-color: transparent; /* Background remains transparent */
        }
        .circle {
            width: 2vw; /* Adjust as needed */
            height: 2vw; /* Make height equal to width for a perfect circle */
            background-color: transparent;
            border-radius: 50%; /* Makes the shape a circle */
        }

        label {
            font-size: 42px; /* Font size for checkbox labels */
            margin-bottom: 10px; /* Space between checkboxes */
            display: flex; /* Use flexbox for better alignment */
            align-items: center; /* Align checkbox and label vertically */
            font-weight: bold; /* Make the label text bold */
            color: lightgrey; /* Change label text color to light grey */
        }

        /* Custom styles for checkboxes based on their names */
        .big-checkbox {
            width: 100px; /* Bigger size for specific checkboxes */
            height: 100px; /* Bigger size for specific checkboxes */
            margin-bottom: 20px; /* Space below the big checkbox */
        }

        .medium-checkbox {
            width: 50px; /* Medium size for specific checkboxes */
            height: 50px; /* Medium size for specific checkboxes */
            margin-bottom: 10px; /* Space below the medium checkbox */
        }

        /* Styles for the Return button */
        #returnButton {
            font-size: 24px; /* Font size for button text */
            margin-bottom: 20px; /* Space below the button */
            padding: 10px 20px; /* Padding for button */
            cursor: pointer; /* Change cursor to pointer */
        }

        /* Styles for the Cursed Settings button */
        #cursedSettingsButton {
            font-size: 24px; /* Font size for button text */
            padding: 10px 20px; /* Padding for button */
            cursor: pointer; /* Change cursor to pointer */
        }

        /* Styles for the PLAY button */
        #playButton {
            font-size: 48px; /* Increase font size for the button */
            margin-top: 20px; /* Space above the button */
            margin-bottom: 70px; /* Space below the button */
            padding: 45px 90px; /* Increase padding for larger button */
            cursor: pointer; /* Change cursor to pointer */
            background-color: #4CAF50; /* Green background */
            color: white; /* White text color */
            border: none; /* Remove border */
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s; /* Smooth background color transition */
        }

        /* Change background color on hover */
        #playButton:hover {
            background-color: #45a049; /* Darker green on hover */
        }

        /* Styles for the Toggle Background button */
        #greyBackgroundButton {
            font-size: 24px; /* Font size for button text */
            padding: 10px 20px; /* Padding for button */
            margin-top: 20px; /* Space above the button */
            background-color: white; /* Light grey background when activated */
            cursor: pointer; /* Change cursor to pointer */
        }

        /* Styles for the X button */
        #reloadButton {
            position: absolute; /* Position relative to body */
            top: 10px; /* Distance from the top */
            right: 0px; /* Distance from the right */
            font-size: 24px; /* Font size for button */
            padding: 3px 3px; /* Padding for button */
            cursor: pointer; /* Change cursor to pointer */
            background-color: transparent; /* Transparent background */
            color: white; /* White text color */
            border: none; /* Remove border */
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s; /* Smooth background color transition */
        }        
        #powerOptionBlue {  
            position: absolute;
            font-size: 2vw; /* Increase font size for the button */
            top: 0%; /* Space above the button */
            bottom: 80%;
            flex-wrap: wrap;
            left: 50%;
            right: 40%;
            font-weight: bold;
            background-color: lightgray;
            padding: 2% 0%; /* Increase padding for larger button */
            cursor: pointer; /* Change cursor to pointer */
            color: blue; /* White text color */
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s;  
        }
        #powerOptionGreen {  
            position: absolute;
            font-size: 2vw; /* Increase font size for the button */
            top: 0%; /* Space above the button */
            bottom: 80%;
            left: 60%;
            right: 30%;
            font-weight: bold;
            background-color: lightgray;
            flex-wrap: wrap;
            padding: 2% 0%; /* Increase padding for larger button */
            cursor: pointer; /* Change cursor to pointer */
            color: rgb(103, 171, 0); /* White text color */
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s;  
        }
        #powerOptionRedGrab {  
            position: absolute;
            font-size: 2vw; /* Increase font size for the button */
            top: 0%; /* Space above the button */
            bottom: 80%;
            flex-wrap: wrap;
            left: 70%;
            right: 20%;
            font-weight: bold;
            background-color: lightgray;
            padding: 2% 0%; /* Increase padding for larger button */
            cursor: pointer; /* Change cursor to pointer */
            color: rgb(231, 84, 84); /* White text color */
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s;  
        }
        #powerOptionRed {  
            position: absolute;
            font-size: 2vw; /* Increase font size for the button */
            top: 0%; /* Space above the button */
            bottom: 80%;
            flex-wrap: wrap;
            left: 80%;
            right: 10%;
            font-weight: bold;
            background-color: lightgray;
            padding: 2% 0%; /* Increase padding for larger button */
            cursor: pointer; /* Change cursor to pointer */
            color: rgb(237, 100, 100); /* White text color */
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s;  
        }
        #powerOptionYellow {  
            position: absolute;
            font-size: 2vw; /* Increase font size for the button */
            top: 0%; /* Space above the button */
            bottom: 80%;
            flex-wrap: wrap;
            left: 90%;
            right: 0%;
            font-weight: bold;
            background-color: lightgray;
            cursor: pointer; /* Change cursor to pointer */
            color: rgb(245, 245, 91); /* White text color */
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s;  
        }
        #startTimer {  
            position: absolute;
            font-size:  2vw; /* Increase font size for the button */
            top: 20%; /* Space above the button */
            bottom: 70%;
            left: 66.6%;
            right: 16.66%;
            font-weight: bold;
            cursor: pointer; /* Change cursor to pointer */
            color: black; /* White text color */
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s;  
        }
        #resetTimer {  
            position: absolute;
            font-size:  2vw; /* Increase font size for the button */
            top: 30%; /* Space above the button */
            bottom: 60%;
            left: 66.6%;
            right: 16.66%;
            font-weight: bold;
            cursor: pointer; /* Change cursor to pointer */
            color: black; /* White text color */
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s;  
        }
        #endRound {  
            position: absolute;
            font-size: 3vw; /* Increase font size for the button */
            top: 20%; /* Space above the button */
            bottom: 60%;
            right: 0%;
            left: 83.33%;
            font-weight: bold;
            cursor: pointer; /* Change cursor to pointer */
            color: black; /* White text color */
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s;  
        }
        #RetryOption {  
            position: absolute;
            font-size:  3vw; /* Increase font size for the button */
            top: 50%; /* Space above the button */
            bottom: 40%;
            right: 33.33%;
            left: 50%;
            font-weight: bold;
            cursor: pointer; /* Change cursor to pointer */
            color: black; /* White text color */
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s;  
        }
        #SelectBlue {  
            position: absolute;
            font-size: 33px; /* Increase font size for the button */
            top: 93%; /* Space above the button */
            bottom: 0%;
            left: 0%;
            right: 90%;
            font-weight: bold;
            cursor: pointer; /* Change cursor to pointer */
            color: black; /* White text color */
            background-color: blue;
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s;  
        } 
        #SelectYellow {  
            position: absolute;
            font-size: 33px; /* Increase font size for the button */
            top: 93%; /* Space above the button */
            bottom: 0%;
            left: 10%;
            right: 80%;
            font-weight: bold;
            cursor: pointer; /* Change cursor to pointer */
            color: black; /* White text color */
            background-color: yellow;
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s;  
        } 
        #SelectGreen {  
            position: absolute;
            font-size: 33px; /* Increase font size for the button */
            top: 93%; /* Space above the button */
            bottom: 0%;
            left: 20%;
            right: 70%;
            font-weight: bold;
            cursor: pointer; /* Change cursor to pointer */
            color: black; /* White text color */
            background-color: #4CAF50;
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s;  
        } 
        #SelectRed {  
            position: absolute;
            font-size: 33px; /* Increase font size for the button */
            top: 93%; /* Space above the button */
            bottom: 0%;
            left: 30%;
            right: 60%;
            font-weight: bold;
            cursor: pointer; /* Change cursor to pointer */
            color: black; /* White text color */
            background-color: red;
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s;  
        }
        #SelectGrey {  
            position: absolute;
            font-size: 33px; /* Increase font size for the button */
            top: 93%; /* Space above the button */
            bottom: 0%;
            left: 40%;
            right: 49%;
            font-weight: bold;
            cursor: pointer; /* Change cursor to pointer */
            color: black; /* White text color */
            background-color: grey;
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s;  
        }
        #UpOption {  
            position: absolute;
            font-size: 4vW; /* Increase font size for the button */
            top: 40%; /* Space above the button */
            bottom: 40%;
            left: 66.6%;
            right: 16.66%;
            font-weight: bold;
            cursor: pointer; /* Change cursor to pointer */
            color: black; /* White text color */
            background-color: #4CAF50;
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s;  
        }
        #undoOption {  
            position: absolute;
            font-size: 4vw; /* Increase font size for the button */
            top: 40%; /* Space above the button */
            bottom: 40%;
            left: 83.33%;
            right: 0%;
            font-weight: bold;
            cursor: pointer; /* Change cursor to pointer */
            color: black; /* White text color */
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s;  
        }
        #DownOption {  
            position: absolute;
            font-size: 4vw; /* Increase font size for the button */
            top: 60%; /* Space above the button */
            bottom: 20%;
            left: 66.6%;
            font-weight: bold;
            right: 16.66%;
            background-color: #4CAF50;
            cursor: pointer; /* Change cursor to pointer */
            color: black; /* White text color */
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s;  
        }
        #LeftOption {  
            position: absolute;
            font-size: 4vw; /* Increase font size for the button */
            top: 60%; /* Space above the button */
            bottom: 20%;
            left: 50%;
            right: 33.33%;
            font-weight: bold;
            background-color: #4CAF50;
            cursor: pointer; /* Change cursor to pointer */
            color: black; /* White text color */
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s;  
        }
        #RightOption {  
            position: absolute;
            font-size: 4vw; /* Increase font size for the button */
            top: 60%; /* Space above the button */
            bottom: 20%;
            left: 83.33%;
            right: 0%;
            font-weight: bold;
            background-color: #4CAF50;
            cursor: pointer; /* Change cursor to pointer */
            color: black; /* White text color */
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s;  
        }
        #timerDisplay {
            position: absolute;
            /*transform: translate(-50%,-50%);*/
            width: 20vw; /* Make the width relative to the viewport width */
            height: 10vh;
            top: 25%;
            right: 28.5%;
            font-size:calc(3.5vw + 3.5vh);
            font-weight: bold;
            color: white;
        }
        #movesLabel {
            position: absolute;
            transform: translate(-50%,-50%);
            width: 20vw; /* Make the width relative to the viewport width */
            height: 5vh;
            top: 43%;
            right: 19%;
            font-size:calc(2vw + 2vh);
            font-weight: bold;
            color: white;
        }
        #movesDisplay {
            position: absolute;
            transform: translate(-50%,-50%);
            width: 20vw; /* Make the width relative to the viewport width */
            height: 5vh;
            top: 43%;
            right: 7%;
            font-size: calc(2vw + 2vh);
            font-weight: bold;
            color: white;
        }
        #p1 {
            position: absolute;
            transform: translate(-50%,-50%);
            width: 20vw; /* Make the width relative to the viewport width */
            height: 5vh;
            top: 95%;
            right: 18%;
            font-size: calc(1.7vw + 1.7vh);
            font-weight: bold;
            color: white;
        }
        #p2 {
            position: absolute;
            transform: translate(-50%,-50%);
            width: 20vw; /* Make the width relative to the viewport width */
            height: 5vh;
            top: 95%;
            right: 6%;
            font-size: calc(1.7vw + 1.7vh);
            font-weight: bold;
            color: white;
        }
        #p3 {
            position: absolute;
            transform: translate(-50%,-50%);
            width: 20vw; /* Make the width relative to the viewport width */
            height: 5vh;
            top: 95%;
            right: -6%;
            font-size: calc(1.7vw + 1.7vh);
            font-weight: bold;
            color: white;
        }
        #p4 {
            position: absolute;
            transform: translate(-50%,-50%);
            width: 20vw; /* Make the width relative to the viewport width */
            height: 5vh;
            top: 95%;
            right: -18%;
            font-size: calc(1.7vw + 1.7vh);
            font-weight: bold;
            color: white;
        }
        #p1p {
            position: absolute;
            transform: translate(-50%,-50%);
            width: 20vw; /* Make the width relative to the viewport width */
            height: 5vh;
            top: 95%;
            right: 11%;
            font-size: calc(1.7vw + 1.7vh);
            font-weight: bold;
            color: white;
        }
        #p2p {
            position: absolute;
            transform: translate(-50%,-50%);
            width: 20vw; /* Make the width relative to the viewport width */
            height: 5vh;
            top: 95%;
            right: -1%;
            font-size: calc(1.7vw + 1.7vh);
            font-weight: bold;
            color: white;
        }
        #p3p {
            position: absolute;
            transform: translate(-50%,-50%);
            width: 20vw; /* Make the width relative to the viewport width */
            height: 5vh;
            top: 95%;
            right: -13%;
            font-size: calc(1.7vw + 1.7vh);
            font-weight: bold;
            color: white;
        }
        #p4p {
            position: absolute;
            transform: translate(-50%,-50%);
            width: 20vw; /* Make the width relative to the viewport width */
            height: 5vh;
            top: 95%;
            right: -25%;
            font-size: calc(1.7vw + 1.7vh);
            font-weight: bold;
            color: white;
        }
        #point1 {  
            position: absolute;
            font-size: 33px; /* Increase font size for the button */
            top: 80%; /* Space above the button */
            bottom: 10%;
            left: 50%;
            right: 37.5%;
            font-weight: bold;
            cursor: pointer; /* Change cursor to pointer */
            color: black; /* White text color */
            background-color: lightgray;
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s;  
        } 
        #point2 {  
            position: absolute;
            font-size: 33px; /* Increase font size for the button */
            top: 80%; /* Space above the button */
            bottom: 10%;
            left: 62.5%;
            right: 25%;
            font-weight: bold;
            cursor: pointer; /* Change cursor to pointer */
            color: black; /* White text color */
            background-color: lightgray;
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s;  
        } 
        #point3 {  
            position: absolute;
            font-size: 33px; /* Increase font size for the button */
            top: 80%; /* Space above the button */
            bottom: 10%;
            left: 75%;
            right: 12.5%;
            font-weight: bold;
            cursor: pointer; /* Change cursor to pointer */
            color: black; /* White text color */
            background-color: lightgray;
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s;  
        } 
        #point4 {  
            position: absolute;
            font-size: 33px; /* Increase font size for the button */
            top: 80%; /* Space above the button */
            bottom: 10%;
            left: 87.5%;
            right: 0%;
            font-weight: bold;
            cursor: pointer; /* Change cursor to pointer */
            color: black; /* White text color */
            background-color: lightgray;
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s;  
        }
        #choosePoint {
            position: absolute;
            font-size: 33px; /* Increase font size for the button */
            top: 50%; /* Space above the button */
            bottom: 50%;
            left: 25;
            right: 75%;
            font-weight: bold;
            cursor: pointer; /* Change cursor to pointer */
            color: black; /* White text color */
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s; 
        }
        
        #reloadButton:hover {
            background-color: rgba(255, 255, 255, 0.3); /* Light background on hover */
        }
        #powerOptionBlue:hover {
            background-color: rgba(255, 255, 255, 0.3); /* Light background on hover */
        }
        #powerOptionGreen:hover {
            background-color: rgba(255, 255, 255, 0.3); /* Light background on hover */
        }
        #powerOptionRedGrab:hover {
            background-color: rgba(255, 255, 255, 0.3); /* Light background on hover */
        }
        #powerOptionRed:hover {
            background-color: rgba(255, 255, 255, 0.3); /* Light background on hover */
        }
        #powerOptionYellow:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }
        #startTimer:hover {
            background-color: rgba(255, 255, 255, 0.3); 
        }
        #resetTimer:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }   
        #UpOption:hover {
            background-color: rgba(255, 255, 255, 0.3); 
        }
        #DownOption:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }
        #LeftOption:hover {
            background-color: rgba(255, 255, 255, 0.3); 
        }
        #RightOption:hover {
            background-color: rgba(255, 255, 255, 0.3);
        } 
        #undoOption:hover {
            background-color: rgba(255, 255, 255, 0.3); 
        }    
        #point1:hover{background-color: rgba(255, 255, 255, 0.3); }
        #point2:hover{background-color: rgba(255, 255, 255, 0.3); }
        #point3:hover{background-color: rgba(255, 255, 255, 0.3); }
        #point4:hover{background-color: rgba(255, 255, 255, 0.3); }
         
    </style>
</head>
<body>
    <!--<button id="reloadButton">X</button>--> <!-- Reload button -->

    <div class="checkbox-container" id="checkboxContainer">
        <!-- Return button -->
        <button id="returnButton">Return</button>
        <label><input type="checkbox" id="bigCheckbox" name="bigOption"> All Powers</label>
        <label><input id="blue" type="checkbox" name="mediumOption"> Blue can teleport</label>
        <label><input id="green" type="checkbox" name="mediumOption"> Green can make a hologram</label>
        <label><input id="red" type="checkbox" name="mediumOption"> Red can grab other robots</label>
        <label><input id="yellow" type="checkbox" name="mediumOption"> Yellow can go through one wall</label>
        <label><input id="grey" type="checkbox" name="mediumOption"> Grey goes through every wall</label>
        <button id="greyBackgroundButton">Dark Mode</button>
    </div>
    <div class="game-container" id="gameContainer">
        <!-- Row One & Row Two-->
        <button id="powerOptionBlue" class="button" name="bluePower">Blue teleport</button>     <!-- Row One & Row Two -->
        <button id="powerOptionGreen" class="button" name="greenPower">Green hologram</button>    <!-- Row One & Row Two -->
        <button id="powerOptionRedGrab" class="button" name="redPower1">Red grab</button>    <!-- Row One & Row Two -->
        <button id="powerOptionRed" class="button" name="redPower2">Red lets go</button>       <!-- Row One & Row Two -->
        <button id="powerOptionYellow" class="button" name="yellowPower">Yellow 1wall</button> <!-- Row One & Row Two -->

        <button id="SelectBlue" class="button" name="blueSel"></button>     <!-- Row One & Row Two -->
        <button id="SelectGreen" class="button" name="greenSel"></button>    <!-- Row One & Row Two -->
        <button id="SelectRed" class="button" name="redSel"></button>       <!-- Row One & Row Two -->
        <button id="SelectYellow" class="button" name="yellowSel"></button> <!-- Row One & Row Two -->
        <button id="SelectGrey" class="button" name="greySel"></button>     <!-- Row One & Row Two -->

        <!-- Row Three & Row Four -->
        <span id="timerDisplay">01:00</span>  
        <button id="startTimer">Start Timer</button> 
        <button id="endRound">End Round</button>     <!-- Row Three -->
        <button id="resetTimer">Reset Timer</button>      <!-- Row Four -->

        <!-- Row Five & Six -->
        <span id="movesLabel">Moves :</span> 
        <span id="movesDisplay">0</span> 
        <!-- Row Five -->
        <button id="RetryOption">Retry</button>           <!-- Row Six  -->
        <button id="UpOption">Up</button>                 <!-- Row Five & Six -->
        <button id="undoOption">Undo</button>             <!-- Row Five & Six -->

        <!-- Row Seven & Eight -->
        <button id="DownOption">Down</button>             <!-- Row Seven & Eight -->
        <button id="LeftOption">Left</button>  <!-- Row Seven & Eight -->
        <button id="RightOption">Right</button> <!-- Row Seven & Eight -->
        <p class= "temp"><span id="choosePoint">GIVE A POINT</span></p>
        <span id="p1p">0</span>
        <span id="p2p">0</span>
        <span id="p3p">0</span>
        <span id="p4p">0</span>
        <div class="points">
            <button id="point1" class="button" name="player 1"></button>     <!-- Row One & Row Two -->
            <button id="point2" class="button" name="player 2"></button>    <!-- Row One & Row Two -->
            <button id="point3" class="button" name="player 3"></button>       <!-- Row One & Row Two -->
            <button id="point4" class="button" name="player 4"></button> <!-- Row One & Row Two -->
        </div>

        <!-- Player Display -->
        <span id="p1">Sim1:</span> 
        <span id="p2">Oli2:</span> 
        <span id="p3">Rng3:</span> 
        <span id="p4">Rng4:</span> 
        <!-- Row Nine & Ten -->
        <!--                    Reserved for Configurable player points                               -->
    </div>
   
    
    <button id="playButton">PLAY</button> <!-- Place the PLAY button here, outside of the checkbox container -->
    <button id="cursedSettingsButton">Cursed Settings</button> <!-- Cursed Settings button below the PLAY button -->
    <div>
      </div>
    <script>
    class Tile {
                constructor(L, U, R, D, bouncerState, state, bouncerColor, objective) {
                    // Set direction states based on the provided state
                    this.L = (state == 1 && L == 1) || (state == 2 && D == 1) || (state == 3 && R == 1) || (state == 4 && U == 1);
                    this.R = (state == 1 && R == 1) || (state == 2 && U == 1) || (state == 3 && L == 1) || (state == 4 && D == 1);
                    this.U = (state == 1 && U == 1) || (state == 2 && L == 1) || (state == 3 && D == 1) || (state == 4 && R == 1);
                    this.D = (state == 1 && D == 1) || (state == 2 && R == 1) || (state == 3 && U == 1) || (state == 4 && L == 1);
                    
                    // Update bouncerState based on conditions
                    this.bouncerState = (bouncerState != 2) ? (bouncerState + state - 1) % 2 : bouncerState;
                    if(bouncerColor == 1)
                    {
                        this.bouncerColor = 'Blue';
                    } else if(bouncerColor == 2)
                    {
                        this.bouncerColor = 'Green';
                    }else if(bouncerColor == 3)
                    {
                        this.bouncerColor = 'Red';
                    } else if(bouncerColor == 4)
                    {
                        this.bouncerColor = 'Yellow';
                    }
                    this.objective = objective;
                    this.hasRobot = false;
                    this.cornerPlaceable = true;
                }
                setL(bool) {
                    this.L = bool;           
                } 
                setU(bool) {
                    this.U = bool;           
                } 
                setD(bool) {
                    this.D = bool;           
                } 
                setR(bool) {
                    this.R = bool;           
                } 
                setIsRobot(bool)
                {
                   this.hasRobot = bool;
                }
                setCornerPlaceable(bool)
                {
                    this.cornerPlaceable = bool;
                }
                setBouncerColor(color)
                {
                    this.bouncerColor = color; 
                }
                setBouncerState(state)
                {   
                    this.bouncerState = state;
                }
            }
            class Robot {
                constructor(row,col,color) {
                    this.color = color;
                    this.row = row;
                    this.col = col;
                    this.isSelected = false;
                    this.pow = false;
                    
                }
                setIsSelected(bool)
                {
                    this.isSelected = bool;
                }
                setRow(row)
                {
                    this.row = row;
                }
                setCol(col)
                {
                    this.col = col;
                }
                getColor()
                {
                    return this.color;
                }
                getIsSelected()
                {
                    return this.isSelected;
                }
                setPow(bool)
                {
                    this.pow = bool;
                }
            }
            class move{
                constructor(row,col,color) {
                    this.color = color;
                    this.row = row;
                    this.col = col;
                }
                getRow()
                {
                    return this.row;
                }
                getCol()
                {
                    return this.col;
                }
                getColor()
                {
                    return this.color;
                }
            }
            class wallType
            { // 0:_| 1:|_  2:|- 3:-|
                constructor(state)
                {
                    this.state = state;
                    if(state == 0)
                    {
                        this.D = 1;
                        this.R = 1;
                        this.U = 0;
                        this.L = 0;
                    }else if(state == 1)
                    {
                        this.L = 1;
                        this.D = 1;
                        this.U = 0;
                        this.R = 0;
                    }else if(state == 2)
                    {
                        this.U = 1;
                        this.L = 1;
                        this.D = 0;
                        this.R = 0;
                    }else if(state == 3)
                    {
                        this.U = 1;
                        this.R = 1;
                        this.L = 0;
                        this.D = 0;
                    }
                    this.box = [this.U, this.D, this.L, this.R];
                }
            }

        const obj = document.createElement('img'); 
        redG = false;
        redY = false;
        redB = false;
        redGrey = false;
        greyPower = false;
        bluePower = false;
        yellowPower = false;
        redPower = false;
        greenPower = false;
        pointGiven = false;
        unGrabbing = false;
        grabbing = false;
        mapRound = 0;
        mapObjectiveRound = 0;
        grappledRobots = [];
        currentObjective = [];
        mapMakingObj = pickMapObjective();
        midObj = [];
        mapHider = [];
        moveHistory = [];
        const tileMapA = 
        [[
        [[1,1,0,0,2,1,1,18],[0,1,1,0,2,1,1,18],[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,1,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,9],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,1,1,0,2,1,1,14],[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,1,2,1,1,3],[1,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,0,0,1,2,1,1,8],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,18]]
        ],[
        [[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,1,0,2,1,1,18],[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,1,2,1,1,3],[1,0,0,0,2,1,1,18]],
        [[1,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,14],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,1,0,2,1,1,8],[1,0,0,0,2,1,1,18]],
        [[1,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,0,0,1,2,1,1,9],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,18]]
        ],[   
        [[1,1,0,0,2,1,1,18],[0,1,1,0,2,1,1,18],[1,1,0,0,2,1,1,18],[0,1,0,1,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,14],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,1,2,1,1,3],[1,0,0,0,2,1,1,18]],
        [[1,0,1,0,2,1,1,18],[1,0,0,1,2,1,1,9],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,1,0,2,1,1,8],[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18]],
        [[1,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,18]]
        ],[   
        [[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,1,0,2,1,1,18],[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,1,1,2,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,9],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,1,2,1,1,3],[1,0,0,0,2,1,1,18]],
        [[1,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,1,0,2,1,1,14],[1,0,0,1,2,1,1,8],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,0,1,4,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,18]]
        ]];
        const tileMapB = 
        [[
        [[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,1,0,2,1,1,18],[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,1,2,1,1,15],[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,1,0,2,1,1,18],[1,0,0,1,2,1,1,12],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,1,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,2],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,1,0,2,1,1,6],[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,18]]
        ],[
        [[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,1,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,1,0,2,1,1,18],[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,2],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,0,0,1,2,1,1,6],[0,0,0,0,2,1,1,18]],
        [[1,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,1,0,2,1,1,12],[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,1,1,2,1,1,15],[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,18]]
        ],[
        [[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,1,0,2,1,1,18],[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,2],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,0,0,1,2,1,1,6],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,1,0,2,1,1,12],[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,1,2,1,1,15],[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,18]]
        ],[
        [[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,1,0,2,1,1,18],[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,1,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,1,2,1,1,15],[1,1,0,0,2,1,1,2],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,0,1,3,18]],
        [[1,0,1,0,2,1,1,18],[1,0,0,1,2,1,1,12],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,1,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18]],
        [[1,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,1,0,2,1,1,6],[1,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,18]]
        ]];
        const tileMapC = 
        [[
        [[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,1,0,2,1,1,18],[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,1,2,1,1,7],[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,1,0,2,1,1,13],[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,1,0,0,2,1,1,18],[0,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,0,0,1,2,1,1,10]],
        [[1,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,4],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,0,1,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,18]]
        ],[
        [[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,1,0,2,1,1,18],[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18]],
        [[1,0,1,0,2,1,1,18],[1,0,0,1,2,1,1,10],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,1,0,2,1,1,13],[1,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,1,2,1,1,7],[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18]],
        [[1,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,4]],
        [[1,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,18]]
        ],[
        [[1,1,0,0,2,1,1,18],[0,1,1,0,2,1,1,18],[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,1,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,1,0,2,1,1,13],[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,1,0,2,1,1,18],[1,0,0,1,2,1,1,10],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,4],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,1,2,1,1,7],[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,18]]
        ],[
        [[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,1,0,2,1,1,18],[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,0,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,1,2,1,1,7],[1,0,0,0,2,1,1,18]],
        [[1,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,0,0,0,1,4,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,1,0,2,1,1,13],[1,0,0,1,2,1,1,10],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,4],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,18]]
        ]];
        const tileMapD =
        [[
        [[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,1,0,2,1,1,18],[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,0,0,1,2,1,1,5],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,1,1,0,2,1,1,1],[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,16],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,1,2,1,1,11],[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,1,2,1,1,17]],
        [[1,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,0,1,2,1,1,18]],
        [[1,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,18]]
        ],[
        [[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,1,0,2,1,1,18],[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,1,2,1,1,11],[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,1,0,2,1,1,18],[1,0,0,1,2,1,1,16],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,1,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,1],[0,0,0,0,2,1,1,18]],
        [[1,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,1,0,2,1,1,5],[1,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,1,2,1,1,17],[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,18]]
        ],[
        [[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,1,0,2,1,1,18],[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,0,0,1,2,1,1,5],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,1,2,1,1,17]],
        [[1,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,0,0,2,1,1,18]],
        [[1,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,1,2,1,1,11],[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,16],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,1,1,0,2,1,1,1],[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,18]]
        ],[
        [[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,1,0,2,1,1,18],[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,0,1,3,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,1],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,1,0,2,1,1,5],[1,0,0,1,2,1,1,16],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,0,2,1,1,18],[0,0,1,1,2,1,1,11],[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
        [[1,0,0,1,2,1,1,18],[0,1,0,0,2,1,1,18],[0,0,0,0,0,1,2,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18]],
        [[1,1,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,1,2,1,1,17],[1,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,18]]
        ]];
        const tileMaps = [tileMapA,tileMapB,tileMapC,tileMapD]
        p1p = 0;
        p2p = 0;
        p3p = 0;
        p4p = 0;
        bigMap = [];
        robotMap = [];
        tempRobotPos = [];
        //bigMap = makeFullMap();
        bigMap = makeGenFullMap();
        moves = 0;
        const numRows = 16; // Number of rows
        const numCols = 16; // Number of columns
        const squareContainer = document.createElement('div'); // Create a container for squares
        document.body.appendChild(squareContainer); // Append container to the body

        // Create an array to hold square elements
        const squares = [];

        
        function makeMap()
        {
            for (let row = 0; row < numRows; row++) {
                for (let col = 0; col < numCols; col++) {
                    const square = document.createElement('div'); // Create a new square
                    square.className = 'square'; // Add class for styling
                    
                    
                    // Position the squares based on row and column indices
                    square.style.left = `${col * 3.075}vw`; // Horizontal position
                    square.style.top = `${row * 5.8}vh`; // Vertical position
                    
                    // Store the square in the array
                    squares.push(square);

                    squareContainer.appendChild(square); // Append square to the container
                    if(bigMap[row][col].objective != 18){
                        addObjectives(row, col, bigMap[row][col]);}
                    changeBorderThickness(row, col, bigMap[row][col]);
                    if(bigMap[row][col].bouncerState != 2){
                        drawBouncer(row, col, bigMap[row][col]);}
                }
            }
        }
        function addObjectives(row, col, tile)
        {
            if(tile.objective == 1){drawTriangle(row, col,'Yellow');}
            if(tile.objective == 9){drawTriangle(row, col,'Red');}
            if(tile.objective == 6){drawTriangle(row, col,'Blue');}
            if(tile.objective == 13){drawTriangle(row, col,'Green');}
            if(tile.objective == 2){drawSquare(row, col,'Yellow');}
            if(tile.objective == 10){drawSquare(row, col,'Red');}
            if(tile.objective == 8){drawSquare(row, col,'Blue');}
            if(tile.objective == 16){drawSquare(row, col,'Green');}
            if(tile.objective == 3){drawHexagon(row, col,'Yellow');}
            if(tile.objective == 11){drawHexagon(row, col,'Red');}
            if(tile.objective == 7){drawHexagon(row, col,'Blue');}
            if(tile.objective == 15){drawHexagon(row, col,'Green');}
            if(tile.objective == 4){drawCircle(row, col,'Yellow');}
            if(tile.objective == 12){drawCircle(row, col,'Red');}
            if(tile.objective == 5){drawCircle(row, col,'Blue');}
            if(tile.objective == 14){drawCircle(row, col,'Green');}
            if(tile.objective == 17){drawRainbowSpiral(row, col,'green');}
        }
        function changeBorderThickness(row, col, tile) {
            const index = row * numCols + col; // Calculate the index in the array
            const square = squares[index]; // Get the square from the array
            if (tile.L){square.style.borderLeft = `${0.45}vw solid black`;};
            if (tile.U){square.style.borderTop = `${0.7}vh solid black`;};
            if (tile.R){square.style.borderRight = `${0.45}vw solid black`;};
            if (tile.D){square.style.borderBottom = `${0.7}vh solid black`;};  
            
        }
        function drawTriangle(row, col, color, code) {
            const index = row * numCols + col; // Calculate the index in the array
            const square = squares[index]; // Get the square from the array

            if (square) {
                // Create an image element for the robot
                const Trig = document.createElement('img');
                Trig.className = 'Trig'; // Add a class for styling
                switch (color) {
                    case 'Blue':
                    Trig.src = '/images/blueTrig.jpg';
                        break;
                    case 'Red':
                        Trig.src = '/images/redTrig.jpg';
                        break;
                    case 'Yellow':
                    Trig.src = '/images/yellowTrig.jpg';
                        break;
                    case 'Green':
                    Trig.src = '/images/greenTrig.jpg';
                        break;
                    default:
                        console.error(`Unknown color: ${color}`);
                        return; // Exit if the color is unknown
                }
                Trig.style.width = '4vh';
                Trig.style.height = '4vh';
                // Position the robot within the parent square (e.g., centered)
                Trig.style.position = 'absolute';
                Trig.style.top = '50%';
                Trig.style.left = '50%';
                Trig.style.transform = 'translate(-50%, -50%)'; // Center the robot in the square

                square.appendChild(Trig); // Append the robot image to the square
            } else {
                console.error(`Square at row ${row}, col ${col} not found.`);
            }
        }
        function drawSquare(row, col, color) {
            const index = row * numCols + col; // Calculate the index in the array
            const square = squares[index]; // Get the square from the array

            if (square) {
                // Create an image element for the robot
                const Sq = document.createElement('img');
                Sq.className = 'Sq'; // Add a class for styling
                switch (color) {
                    case 'Blue':
                    Sq.src = '/images/blueSq.jpg';
                        break;
                    case 'Red':
                        Sq.src = '/images/redSq.jpg';
                        break;
                    case 'Yellow':
                    Sq.src = '/images/yellowSq.jpg';
                        break;
                    case 'Green':
                    Sq.src = '/images/greenSq.jpg';
                        break;
                    default:
                        console.error(`Unknown color: ${color}`);
                        return; // Exit if the color is unknown
                }
                Sq.style.width = '4vh';
                Sq.style.height = '4vh';
                // Position the robot within the parent square (e.g., centered)
                Sq.style.position = 'absolute';
                Sq.style.top = '50%';
                Sq.style.left = '50%';
                Sq.style.transform = 'translate(-50%, -50%)'; // Center the robot in the square

                square.appendChild(Sq); // Append the robot image to the square
            } else {
                console.error(`Square at row ${row}, col ${col} not found.`);
            }
        }
        function drawHexagon(row, col, color) {
            const index = row * numCols + col; // Calculate the index in the array
            const square = squares[index]; // Get the square from the array

            if (square) {
                // Create an image element for the robot
                const Hex = document.createElement('img');
                Hex.className = 'Hex'; // Add a class for styling
                switch (color) {
                    case 'Blue':
                    Hex.src = '/images/blueHex.jpg';
                        break;
                    case 'Red':
                        Hex.src = '/images/redHex.jpg';
                        break;
                    case 'Yellow':
                    Hex.src = '/images/yellowHex.jpg';
                        break;
                    case 'Green':
                    Hex.src = '/images/greenHex.jpg';
                        break;
                    default:
                        console.error(`Unknown color: ${color}`);
                        return; // Exit if the color is unknown
                }
                Hex.style.width = '4vh';
                Hex.style.height = '4vh';
                // Position the robot within the parent square (e.g., centered)
                Hex.style.position = 'absolute';
                Hex.style.top = '50%';
                Hex.style.left = '50%';
                Hex.style.transform = 'translate(-50%, -50%)'; // Center the robot in the square

                square.appendChild(Hex); // Append the robot image to the square
            } else {
                console.error(`Square at row ${row}, col ${col} not found.`);
            }
        }
        function drawCircle(row, col, color) {
            const index = row * numCols + col; // Calculate the index in the array
            const square = squares[index]; // Get the square from the array

            if (square) {
                // Create an image element for the robot
                const circle = document.createElement('img');
                circle.className = 'circle'; // Add a class for styling
                switch (color) {
                    case 'Blue':
                    circle.src = '/images/blueCircle.jpg';
                        break;
                    case 'Red':
                        circle.src = '/images/redCircle.jpg';
                        break;
                    case 'Yellow':
                    circle.src = '/images/yellowCircle.jpg';
                        break;
                    case 'Green':
                    circle.src = '/images/greenCircle.jpg';
                        break;
                    default:
                        console.error(`Unknown color: ${color}`);
                        return; // Exit if the color is unknown
                }
                circle.style.width = '4vh';
                circle.style.height = '4vh';
                // Position the robot within the parent square (e.g., centered)
                circle.style.position = 'absolute';
                circle.style.top = '50%';
                circle.style.left = '50%';
                circle.style.transform = 'translate(-50%, -50%)'; // Center the robot in the square

                square.appendChild(circle); // Append the robot image to the square
            } else {
                console.error(`Square at row ${row}, col ${col} not found.`);
            }
        }
        function drawRainbowSpiral(row, col) {
            const index = row * numCols + col; // Calculate the index in the array
            const square = squares[index]; // Get the square from the array

            if (square) {
                // Create an image element for the robot
                const spiral = document.createElement('img');
                spiral.className = 'spiral'; // Add a class for styling
                spiral.src = '/images/Rainbow.png'; // Replace with the actual path to your robot image
                spiral.alt = 'Robot'; // Add alt text for accessibility
                // Set the size of the robot image
                spiral.style.width = '5vh';
                spiral.style.height = '5vh';
                // Position the robot within the parent square (e.g., centered)
                spiral.style.position = 'absolute';
                spiral.style.top = '50%';
                spiral.style.left = '50%';
                spiral.style.transform = 'translate(-50%, -50%)'; // Center the robot in the square

                square.appendChild(spiral); // Append the robot image to the square
            } else {
                console.error(`Square at row ${row}, col ${col} not found.`);
            }
        }
        function drawBouncer(row, col, object) {
            // Determine the direction based on bouncerState
            let direction = '';
            if (object.bouncerState == 1) {
                direction = 'top-left-bottom-right';
            } else {
                direction = 'top-right-bottom-left';
            }

            // Determine the color based on bouncerColor
            let color = '';
            switch(object.bouncerColor) {
                case 'Blue':
                    color = 'blue';
                    break;
                case 'Green':
                    color = 'green';
                    break;
                case 'Red':
                    color = 'red';
                    break;
                case 'Yellow':
                    color = 'yellow';
                    break;
                default:
                    console.error('Invalid bouncer color.');
                    return; // Exit if the color is invalid
            }

            // Calculate the index and get the square
            const index = row * numCols + col; // Assuming numCols is globally defined
            const square = squares[index]; // Get the square from the array

            if (square) {
                const diagonalLine = document.createElement('div');
                diagonalLine.className = 'diagonal';    

                // Set the size and color of the diagonal line
                diagonalLine.style.backgroundColor = color; // Use the dynamic color variable
                diagonalLine.style.width = '0.6vw'; // Set the line width (can adjust as needed)
                diagonalLine.style.height = '100%'; // Full height of the square
                diagonalLine.style.border = '1px solid black'; // Add a thin black border
                diagonalLine.style.borderRadius = '50%'; // Ensure the div is circular
                // Position the line within the parent square (centered at the middle)
                diagonalLine.style.position = 'absolute';
                diagonalLine.style.top = '0';
                diagonalLine.style.left = '50%';
                diagonalLine.style.transformOrigin = 'center';

                // Apply rotation based on the direction of the diagonal
                if (direction === 'top-left-bottom-right') {
                    diagonalLine.style.transform = 'translateX(-50%) rotate(45deg)'; // Top-left to bottom-right
                } else if (direction === 'top-right-bottom-left') {
                    diagonalLine.style.transform = 'translateX(-50%) rotate(-45deg)'; // Top-right to bottom-left
                } else {
                    console.error('Invalid direction. Use "top-left-bottom-right" or "top-right-bottom-left".');
                    return;
                }

                square.appendChild(diagonalLine); // Append the diagonal line to the parent square
            } else {
                console.error(`Square at row ${row}, col ${col} not found.`);
            }
        }

        

        function drawRobot(row, col, color) {
            const index = row * numCols + col; // Calculate the index in the array
            const square = squares[index]; // Get the square from the array

            if (square) {
                const targetSquare = squares[index];
                bigMap[row][col].setIsRobot(true);
                
                // Create an image element for the robot
                const robot = document.createElement('img');
                robot.className = 'robot'; // Add a class for styling

                // Set the robot image source based on the color
                switch (color) {
                    case 'Grey':
                        robot.src = '/images/Grey.jpg'; 
                        break;
                    case 'Blue':
                        robot.src = '/images/Blue.jpg';
                        break;
                    case 'Red':
                        robot.src = '/images/Red.jpg';
                        break;
                    case 'Yellow':
                        robot.src = '/images/Yellow.jpg';
                        break;
                    case 'Green':
                        robot.src = '/images/Green.jpg';
                        break;
                    case 'LightGreeen':
                        robot.src = '/images/LightGreeen.jpg';
                        break;
                    default:
                        console.error(`Unknown color: ${color}`);
                        return; // Exit if the color is unknown
                }
                
                robot.alt = 'Robot'; // Add alt text for accessibility

                // Set the size of the robot image
                robot.style.width = '5vh';
                robot.style.height = '5vh';

                // Position the robot within the parent square (e.g., centered)
                robot.style.position = 'absolute';
                robot.style.top = '50%';
                robot.style.left = '50%';
                robot.style.transform = 'translate(-50%, -50%)'; // Center the robot in the square

                // Add click event listener to the robot image
                robot.addEventListener('click', function() {
                    onRobotClick(color); // Call your custom click handler function
                });

                square.appendChild(robot); // Append the robot image to the square
            } else {
                console.error(`Square at row ${row}, col ${col} not found.`);
            }
        }

        // Define the function that will be triggered when a robot is clicked
        function onRobotClick(color) {

            
            for(i=0;i<robotMap.length;i++)
            {   
                robotMap[i].setIsSelected(false);
                if(grabbing)
                {
                    grappledRobots[0] = robotMap[4];
                    if(robotMap[i].col == robotMap[4].col && (robotMap[i].row == robotMap[4].row + 1 || robotMap[i].row == robotMap[4].row - 1) 
                    || robotMap[i].row == robotMap[4].row && (robotMap[i].col == robotMap[4].col + 1 || robotMap[i].col == robotMap[4].col - 1))
                    {
                        grabbing = false;
                        document.getElementById("powerOptionRedGrab").style.backgroundColor = 'lightgray';
                        if((robotMap[i].getColor() && color) == 'Blue' && !grappledRobots.includes(robotMap[1]))
                        {
                            redB = true;
                            grappledRobots[grappledRobots.length] = robotMap[1];
                            console.log("redB = : " + redB);
                            moveHistory[moveHistory.length] = new move('Blue', 0, 1);
                        }
                        else if((robotMap[i].getColor() && color) == 'Green' && !grappledRobots.includes(robotMap[3]))
                        {
                            redG = true;
                            grappledRobots[grappledRobots.length] = robotMap[3];
                            console.log("redG = : " + redG);
                            moveHistory[moveHistory.length] = new move('Green', 0, 1);
                        }
                        else if((robotMap[i].getColor() && color) == 'Yellow' && !grappledRobots.includes(robotMap[2]))
                        {
                            redY = true;
                            grappledRobots[grappledRobots.length] = robotMap[2];
                            console.log("redY = : " + redY);
                            moveHistory[moveHistory.length] = new move('Yellow', 0, 1);
                        }
                        else if((robotMap[i].getColor() && color) == 'Grey' && !grappledRobots.includes(robotMap[0]))
                        {
                            redGrey = true;
                            grappledRobots[grappledRobots.length] = robotMap[0];
                            console.log("redGrey = : " + redGrey);
                            moveHistory[moveHistory.length] = new move('Grey', 0, 1);
                        }
                        
                    }
                }
                if(unGrabbing)
                {
                    document.getElementById("powerOptionRed").style.backgroundColor = 'lightgray';
                    if(robotMap[i].color == 'Blue' && color == 'Blue' && grappledRobots.includes(robotMap[1]))
                    {
                        unGrabbing = false;
                        redB = false;
                        grappledRobots.splice(grappledRobots.indexOf(robotMap[1]), 1);
                        console.log("redB = : " + redB);
                        moveHistory[moveHistory.length] = new move('Blue', 1, 1);
                    }
                    else if(robotMap[i].color == 'Green' && color == 'Green' && grappledRobots.includes(robotMap[3]))
                    {
                        unGrabbing = false;
                        redG = false;
                        grappledRobots.splice(grappledRobots.indexOf(robotMap[3]), 1);
                        console.log("redG = : " + redG);
                        moveHistory[moveHistory.length] = new move('Green', 1, 1);
                    }
                    else if(robotMap[i].color == 'Yellow' && color == 'Yellow' && grappledRobots.includes(robotMap[2]))
                    {
                        unGrabbing = false;
                        redY = false;
                        grappledRobots.splice(grappledRobots.indexOf(robotMap[2]), 1);
                        console.log("redY = : " + redY);
                        moveHistory[moveHistory.length] = new move('Yellow', 1, 1);
                    }
                    else if(robotMap[i].color == 'Grey' && color == 'Grey' && grappledRobots.includes(robotMap[0]))
                    {
                        unGrabbing = false;
                        redGrey = false;
                        grappledRobots.splice(grappledRobots.indexOf(robotMap[0]), 1);
                        console.log("redGrey = : " + redGrey);
                        moveHistory[moveHistory.length] = new move('Grey', 1, 1);
                    }
                }
                if(robotMap[i].color == color && robotMap[i].isSelected == false)
                {
                    //console.log(`Robot at row ${robotMap[i].row}, col ${robotMap[i].col} with color ${color} was clicked!`);
                    robotMap[i].setIsSelected(true);
                    document.body.style.backgroundColor = color;
                    const label= document.querySelectorAll('span');
                    if(document.body.style.backgroundColor == 'yellow')
                    {
                        label.forEach(label => {
                            label.style.color = 'black'; // Set label color
                        });
                    }
                    else{
                        label.forEach(label => {
                            label.style.color = 'white'; // Set 
                        });
                    }
                }
            }
            // Add any other functionality you want here
        }

        // Function to handle the undefined functionality
        function undefinedFunction(option) {
            //console.log("Undefined function triggered!");

            for (let j = 0; j < robotMap.length; j++){
                if (robotMap[j].getIsSelected() === true){
                    // Correctly initialize array
                    mauve = new move(robotMap[j].row, robotMap[j].col, robotMap[j].getColor());
                    
                    let array = [0,0];
                    //console.log(array);
                    insureRobots();
                    if(!grappledRobots.includes(robotMap[j]))
                    {
                        if (!robotMap[j].pow) 
                        {
                            array = isStoppingLocation(robotMap[j], option);
                        } else {
                            array = destinationWithPowers(robotMap[j], option);
                        }
                        //console.log(array);
                        // Check if array is defined and contains at least two valid elements
                        if (Array.isArray(array) && array.length >= 2 && (robotMap[j].col != array[1] || robotMap[j].row != array[0])) {
                            moveHistory[moveHistory.length] = (mauve);
                            moveRobot(array[0], array[1], robotMap[j].getColor());
                            uptickMovesDisplay();
                        } else {
                            moveRobot(robotMap[j].row, robotMap[j].col, robotMap[j].getColor());
                        }
                    }
                    else
                    {
                        
                        if(grappledRobots.includes(robotMap[3]) && robotMap.length == 6)
                        {
                            resetHolo();
                        }
                        if(grappledRobots.includes(robotMap[1]) && robotMap[1].pow == true)
                        {
                            if(verifyBlueGroup(option))
                            {
                                uptickMovesDisplay();
                                robotMap[1].setPow(false);
                                document.getElementById("powerOptionBlue").style.backgroundColor = 'lightgray';
                            }
                        }
                        else
                        {
                            verifyDistNormal(option);
                        }
                        
                    }
                }
            }
        }
        
        SelectRed.addEventListener('click', () => {
            onRobotClick('Red');
        });
        SelectGreen.addEventListener('click', () => {
            onRobotClick('Green');
        });
        SelectBlue.addEventListener('click', () => {
            onRobotClick('Blue');
        });
        SelectYellow.addEventListener('click', () => {
            onRobotClick('Yellow');
        });
        SelectGrey.addEventListener('click', () => {
            onRobotClick('Grey');
        });

        powerOptionBlue.addEventListener('click', () => {


            if(robotMap[1].pow == true)
            {
                robotMap[1].pow = false;
                document.getElementById("powerOptionBlue").style.backgroundColor = 'lightgray'; 
            }
            else{
                robotMap[1].pow = true;
                document.getElementById("powerOptionBlue").style.backgroundColor = 'blue';
                document.getElementById("powerOptionYellow").style.backgroundColor = 'lightgray';
                document.getElementById("powerOptionGreen").style.backgroundColor ='lightgray';
                document.getElementById("powerOptionRedGrab").style.backgroundColor = 'lightgray';
                document.getElementById("powerOptionRed").style.backgroundColor = 'lightgray';
            }
        });
        powerOptionRed.addEventListener('click', () => {

            if(unGrabbing == true)
            {
                unGrabbing = false;
                document.getElementById("powerOptionRedGrab").style.backgroundColor = 'lightgray';
            }
            else
            {
                unGrabbing = true;
                document.getElementById("powerOptionBlue").style.backgroundColor = 'lightgray';
                document.getElementById("powerOptionYellow").style.backgroundColor = 'lightgray';
                document.getElementById("powerOptionGreen").style.backgroundColor ='lightgray';
                document.getElementById("powerOptionRedGrab").style.backgroundColor = 'lightgray';
                document.getElementById("powerOptionRed").style.backgroundColor = 'red';
            }
            
        });
        powerOptionRedGrab.addEventListener('click', () => {
            if(robotMap[4].pow == true && grabbing == true)
            {
                grabbing = false;
                robotMap[4].pow = false; 
                document.getElementById("powerOptionRedGrab").style.backgroundColor = 'lightgray';
            }
            else
            {
                robotMap[4].pow = true;
                grabbing = true;
                document.getElementById("powerOptionBlue").style.backgroundColor = 'lightgray';
                document.getElementById("powerOptionYellow").style.backgroundColor = 'lightgray';
                document.getElementById("powerOptionGreen").style.backgroundColor ='lightgray';
                document.getElementById("powerOptionRedGrab").style.backgroundColor = 'red';
                document.getElementById("powerOptionRed").style.backgroundColor = 'lightgray';
            }
            
        });
        powerOptionGreen.addEventListener('click', () => {
            if(robotMap.length == 5)
            {
                robotMap[5] = new Robot(robotMap[3].row,robotMap[3].col,'LightGreeen');
                drawRobot(robotMap[3].row,robotMap[3].col,'LightGreeen');
                document.body.style.backgroundColor = 'lightGreen';
                for(i=1;i< robotMap.length;i++)
                {robotMap[i].pow = false;}
                robotMap[5].pow = true;
                unselectRobots();
                robotMap[5].setIsSelected(true);
                document.getElementById("powerOptionBlue").style.backgroundColor = 'lightgray';
                document.getElementById("powerOptionYellow").style.backgroundColor = 'lightgray';
                document.getElementById("powerOptionGreen").style.backgroundColor ='green';
                document.getElementById("powerOptionRedGrab").style.backgroundColor = 'lightgray';
                document.getElementById("powerOptionRed").style.backgroundColor = 'lightgray';
            }
        });
        powerOptionYellow.addEventListener('click', () => {

            if(robotMap[2].pow == true)
            {
                robotMap[2].pow = false;
                document.getElementById("powerOptionYellow").style.backgroundColor = 'lightgray'; 
            }
            else{
                robotMap[2].pow = true;
                document.getElementById("powerOptionBlue").style.backgroundColor = 'lightgray';
                document.getElementById("powerOptionYellow").style.backgroundColor = 'yellow';
                document.getElementById("powerOptionGreen").style.backgroundColor ='lightgray';
                document.getElementById("powerOptionRedGrab").style.backgroundColor = 'lightgray';
                document.getElementById("powerOptionRed").style.backgroundColor = 'lightgray';
            }
        });
        


        RetryOption.addEventListener('click', () => {
            moves = -1;
            uptickMovesDisplay();
            resetScreen();
        });
        UpOption.addEventListener('click', () => {
            undefinedFunction('UpOption');
        });
        DownOption.addEventListener('click', () => {
            undefinedFunction('DownOption');
        });
        LeftOption.addEventListener('click', () => {
            undefinedFunction('LeftOption');
        });
        RightOption.addEventListener('click', () => {
            undefinedFunction('RightOption');
        });
        document.addEventListener('keydown', function(event) {
            if (event.key === 'ArrowUp' || event.key === 'W' || event.key === 'w') {
               undefinedFunction('UpOption');
            }
            if (event.key === 'ArrowDown' || event.key === 'S' || event.key === 's') {
                undefinedFunction('DownOption');
            }
            if (event.key === 'ArrowLeft' || event.key === 'A' || event.key === 'a') {
                undefinedFunction('LeftOption');
            }
            if (event.key === 'ArrowRight' || event.key === 'D' || event.key === 'd') {
                undefinedFunction('RightOption');
            }
            if (event.key === 'R' || event.key === 'r') {
            location.reload();
            }
        });
                        
        function moveRobot(row, col, color) {
            // Find the existing robot with the given color
            const robots = document.querySelectorAll('.robot');
            let robotToMove = null;
            
            robots.forEach((robot) => {
                if (robot.src.includes(color)) {
                    robotToMove = robot;   
                }
            });

            if (!robotToMove) {
                console.error(`Robot with color ${color} not found.`);
                return;
            }
            
            for(i=0;i<robotMap.length;i++)
            {
                if(robotMap[i].color == color)
                {
                    bigMap[robotMap[i].row][robotMap[i].col].setIsRobot(false);
                    robotMap[i].setRow(row);
                    robotMap[i].setCol(col);
                }
            }
            
            // Calculate the new index and get the target square
            const index = row * numCols + col;
            const targetSquare = squares[index];

            if (targetSquare) {
                // Remove the robot from its current parent and append it to the new square
                robotToMove.parentElement.removeChild(robotToMove);
                
                targetSquare.appendChild(robotToMove);
                bigMap[row][col].setIsRobot(true);

                // Position the robot within the parent square (e.g., centered)
                robotToMove.style.top = '50%';
                robotToMove.style.left = '50%';
                robotToMove.style.transform = 'translate(-50%, -50%)';
                insureRobots();
            } else {
                console.error(`Target square at row ${row}, col ${col} not found.`);
            }
        }

        function generateRobotPos() {
            const forbiddenPositions = ['7,7', '7,8', '8,7', '8,8'];
            const positions = new Set();

            while (positions.size < 5) {
                const row = Math.floor(Math.random() * 16); // Random row from 0 to 17
                const col = Math.floor(Math.random() * 16); // Random col from 0 to 17
                const pos = `${row},${col}`;

                if (!forbiddenPositions.includes(pos) && !positions.has(pos)) {
                    positions.add(pos);
                }
            }

            // Convert the set into an array of coordinate pairs
            return Array.from(positions).map((pos) => {
                const [row, col] = pos.split(',').map(Number);
                return [row, col];
            });
        }
        function generateRobots()
        {
            vals = generateRobotPos();
            drawRobot(vals[0][0],vals[0][1],'Grey');
            robotMap[0] = new Robot(vals[0][0],vals[0][1],'Grey');
            drawRobot(vals[1][0],vals[1][1],'Blue');
            robotMap[1] = new Robot(vals[1][0],vals[1][1],'Blue');
            drawRobot(vals[2][0],vals[2][1],'Yellow');
            robotMap[2] = new Robot(vals[2][0],vals[2][1],'Yellow');
            drawRobot(vals[3][0],vals[3][1],'Green');
            robotMap[3] = new Robot(vals[3][0],vals[3][1],'Green');
            drawRobot(vals[4][0],vals[4][1],'Red');
            robotMap[4] = new Robot(vals[4][0],vals[4][1],'Red');
            
        }
        function isStoppingLocation(robotObject, option)
        {
            if(robotObject.getColor() == 'Green' && robotMap.length == 6)
            {
                resetHolo();
            }
            
            if(option == 'UpOption')
            {   
                if(!bigMap[robotObject.row][robotObject.col].U && !bigMap[robotObject.row - 1][robotObject.col].hasRobot)
                {
                    for(t = robotObject.row - 1; t >= 0; t--)
                    {//check if bottom wall exists then bouncer then higher wall!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        
                        if(bigMap[t][robotObject.col].bouncerState != 2 && robotObject.color != bigMap[t][robotObject.col].bouncerColor)
                        {
                            robotObject.setRow(t);
                            if(bigMap[t][robotObject.col].bouncerState == 0)
                            {
                                return isStoppingLocation(robotObject, 'LeftOption');
                            }
                            else if(bigMap[t][robotObject.col].bouncerState == 1)
                            {
                                return isStoppingLocation(robotObject, 'RightOption');
                            }
                        }
                        else if (bigMap[t][robotObject.col].U)
                        {
                            return [t, robotObject.col];
                        }
                        else if(t != 0)
                        {
                            if(bigMap[t - 1][robotObject.col].hasRobot)
                            {return [t, robotObject.col];}
                        }
                    }
                }
                else{return [robotObject.row, robotObject.col];}
            }
            if(option == 'DownOption')
            {                
                if(!bigMap[robotObject.row][robotObject.col].D && !bigMap[robotObject.row + 1][robotObject.col].hasRobot)
                {
                    for(t = robotObject.row + 1; t <= 15; t++)
                    {
                        if(bigMap[t][robotObject.col].bouncerState != 2 && robotObject.color != bigMap[t][robotObject.col].bouncerColor)
                        {
                            robotObject.setRow(t);
                            if(bigMap[t][robotObject.col].bouncerState == 0)
                            {
                                return isStoppingLocation(robotObject, 'RightOption');
                            }
                            else if(bigMap[t][robotObject.col].bouncerState == 1)
                            {
                            return isStoppingLocation(robotObject, 'LeftOption');
                            }
                        }
                        else if (bigMap[t][robotObject.col].D)
                        {
                            return [t, robotObject.col];
                        }
                        else if(t != 15)
                        {
                            if(bigMap[t + 1][robotObject.col].hasRobot)
                            {return [t, robotObject.col];}
                        }
                    }
                }
                else{return [robotObject.row, robotObject.col];}
            }
            if(option == 'LeftOption')
            {
                if(!bigMap[robotObject.row][robotObject.col].L && !bigMap[robotObject.row ][robotObject.col - 1].hasRobot)
                {
                    for(t = robotObject.col - 1; t >= 0; t--)
                    {
                        if(bigMap[robotObject.row][t].bouncerState != 2 && robotObject.color != bigMap[robotObject.row][t].bouncerColor)
                        {
                            robotObject.setCol(t);
                            if(bigMap[robotObject.row][t].bouncerState == 0)
                            {
                                return isStoppingLocation(robotObject, 'UpOption');
                            }
                            else if(bigMap[robotObject.row][t].bouncerState == 1)
                            {
                            return isStoppingLocation(robotObject, 'DownOption');
                            }
                        }
                        else if (bigMap[robotObject.row][t].L)
                        {
                            return [robotObject.row, t];
                        }
                        else if(t != 0)
                        {
                            if(bigMap[robotObject.row][t - 1].hasRobot)
                            {return [robotObject.row, t];}
                        }
                    }
                }
                else{return [robotObject.row, robotObject.col];}
            }
            if(option == 'RightOption')
            {
                if(!bigMap[robotObject.row][robotObject.col].R && !bigMap[robotObject.row ][robotObject.col + 1].hasRobot)
                {
                    for(t = robotObject.col + 1; t <= 15; t++)
                    {
                        if(bigMap[robotObject.row][t].bouncerState != 2 && robotObject.color != bigMap[robotObject.row][t].bouncerColor)
                        {
                            robotObject.setCol(t);
                            if(bigMap[robotObject.row][t].bouncerState == 0)
                            {
                                return isStoppingLocation(robotObject, 'DownOption');
                            }
                            else if(bigMap[robotObject.row][t].bouncerState == 1)
                            {
                            return isStoppingLocation(robotObject, 'UpOption');
                            }
                        }
                        else if (bigMap[robotObject.row][t].R)
                        {
                            return [robotObject.row, t];
                        }
                        else if(t != 15)
                        {
                            if(bigMap[robotObject.row][t + 1].hasRobot)
                            {return [robotObject.row, t];}
                        }
                    }
                }
                else{return [robotObject.row, robotObject.col];}
            }
        }

        //Make it so that pressing the green power a second time makes you tak control of the hologram
        //Blue lands on a bouncer and doesnt bounce back in a direction as a result.
        //Add the green holo a power condition as true, as the 5th robot + jgp, his movement is in the dstinationWithPowers and hes called 'Lightgreen' color


        function destinationWithPowers(robotObject, option)
        {
            if(option == 'UpOption')
            {
                if(robotObject.row != 0)
                {
                    if(robotObject.getColor() == 'Grey')
                    {
                        if((robotObject.col == 7 || robotObject.col == 8) && !bigMap[robotObject.row - 1][robotObject.col].hasRobot && robotObject.row >= 9)
                        {
                            for(i = robotObject.row - 1; i >= 9; i--)
                            {
                                if(bigMap[i][robotObject.col].bouncerState != 2 && robotObject.color != bigMap[i][robotObject.col].bouncerColor)
                                {
                                    robotObject.setRow(i);
                                    if(bigMap[i][robotObject.col].bouncerState == 0)
                                    {
                                        return destinationWithPowers(robotObject, 'LeftOption');
                                    }
                                    else if(bigMap[i][robotObject.col].bouncerState == 1)
                                    {
                                        return destinationWithPowers(robotObject, 'RightOption');
                                    }
                                }
                                else if(i != 9)
                                {
                                    if(bigMap[i - 1][robotObject.col].hasRobot)
                                    {return [i, robotObject.col];}
                                }
                                else{
                                    return [9, robotObject.col];
                                }
                            }
                        }
                        else if(!bigMap[robotObject.row - 1][robotObject.col].hasRobot){
                            
                            for(i = robotObject.row - 1; i >= 0; i--)
                            {
                                if(bigMap[i][robotObject.col].bouncerState != 2 && robotObject.color != bigMap[i][robotObject.col].bouncerColor)
                                {
                                    robotObject.setRow(i);
                                    if(bigMap[i][robotObject.col].bouncerState == 0)
                                    {
                                        return destinationWithPowers(robotObject, 'LeftOption');
                                    }
                                    else if(bigMap[i][robotObject.col].bouncerState == 1)
                                    {
                                        return destinationWithPowers(robotObject, 'RightOption');
                                    }
                                }
                                else if(i != 0)
                                {
                                    if(bigMap[i - 1][robotObject.col].hasRobot)
                                    {return [i, robotObject.col];}
                                }
                                else{
                                    return [0, robotObject.col];
                                }
                            }
                        }
                    }
                
                    if(robotObject.getColor() == 'Blue')
                    {
                        robotObject.setPow(false);
                        document.getElementById("powerOptionBlue").style.backgroundColor = 'lightgray';
                        if(robotObject.row - 4 >= 0 && !redB)
                        {
                            if(!((robotObject.row - 4 == 7 || robotObject.row - 4 == 8) && (robotObject.col == 7 || robotObject.col == 8 )))
                            {
                                if(!bigMap[robotObject.row - 4][robotObject.col].hasRobot)
                                {
                                    return [robotObject.row - 4, robotObject.col];
                                }
                            }
                        }
                        else if(robotObject.row - 4 >= 0)
                        {
                            verifyBlueGroup('UpOption');
                        }
                    }

                    if(robotObject.getColor() == 'Yellow')
                    {//ALORS CE CODE N'EST PAS BON FAIT COMME AEVC LE GRIS POUR L MILIEU, LES COTÉS ET LES ROBOTS (SO ITS BASICALLY JUST DONT FORGET THE CONDITIONS.)
                        if((robotObject.col == 7 || robotObject.col == 8) && !bigMap[robotObject.row - 1][robotObject.col].hasRobot && robotObject.row >= 9)
                        {
                            for(i = robotObject.row; i >= 9; i--)
                            {
                                if(bigMap[i][robotObject.col].bouncerState != 2 && robotObject.color != bigMap[i][robotObject.col].bouncerColor && robotObject.row != i)
                                {
                                    robotObject.setRow(i);
                                    if(bigMap[i][robotObject.col].bouncerState == 0)
                                    {
                                        return destinationWithPowers(robotObject, 'LeftOption');
                                    }
                                    else if(bigMap[i][robotObject.col].bouncerState == 1)
                                    {
                                        return destinationWithPowers(robotObject, 'RightOption');
                                    }
                                }
                                else if (bigMap[i][robotObject.col].U && i != 9)
                                {
                                    robotObject.setRow(i - 1);
                                    robotObject.setPow(false);
                                    document.getElementById("powerOptionYellow").style.backgroundColor = 'lightgray';
                                    return isStoppingLocation(robotObject, 'UpOption');
                                }
                                else if(i != 9)
                                {
                                    if(bigMap[i - 1][robotObject.col].hasRobot)
                                    {return [i, robotObject.col];}
                                }
                                else{
                                    return [9, robotObject.col];
                                }
                            }
                        }
                        else if(!bigMap[robotObject.row - 1][robotObject.col].hasRobot)
                        {
                            
                            for(i = robotObject.row; i >= 0; i--)
                            {
                                if(bigMap[i][robotObject.col].bouncerState != 2 && robotObject.color != bigMap[i][robotObject.col].bouncerColor && robotObject.row != i)
                                {
                                    robotObject.setRow(i);
                                    if(bigMap[i][robotObject.col].bouncerState == 0)
                                    {
                                        return destinationWithPowers(robotObject, 'LeftOption');
                                    }
                                    else if(bigMap[i][robotObject.col].bouncerState == 1)
                                    {
                                        return destinationWithPowers(robotObject, 'RightOption');
                                    }
                                    break;
                                }
                                else if (bigMap[i][robotObject.col].U && i != 0)
                                {
                                    robotObject.setRow(i - 1);
                                    robotObject.setPow(false);
                                    document.getElementById("powerOptionYellow").style.backgroundColor = 'lightgray';
                                    return isStoppingLocation(robotObject, 'UpOption');
                                }
                                else if(i != 0)
                                {
                                    if(bigMap[i - 1][robotObject.col].hasRobot)
                                    {return [i, robotObject.col];}
                                }
                                else{
                                    return [0, robotObject.col];
                                }
                            }
                        }
                    }

                    if(robotObject.getColor() == 'LightGreeen')
                    {
                        moves--;
                        return [robotObject.row - 1, robotObject.col];
                    }

                    if(robotObject.getColor() == 'Red')
                    {
                        verifyDistNormal(option);
                        //verifyBlueGroup(option);
                    }
                }
            }
            if(option == 'DownOption')
            {        
                if(robotObject.row != 15)
                {
                    if(robotObject.getColor() == 'Grey')
                    { 
                        if((robotObject.col == 7 || robotObject.col == 8) && !bigMap[robotObject.row + 1][robotObject.col].hasRobot && robotObject.row <= 6)
                        {
                            for(i = robotObject.row + 1; i <= 6; i++)
                            {
                                if(bigMap[i][robotObject.col].bouncerState != 2 && robotObject.color != bigMap[i][robotObject.col].bouncerColor)
                                {
                                    robotObject.setRow(i);
                                    if(bigMap[i][robotObject.col].bouncerState == 0)
                                    {
                                        return destinationWithPowers(robotObject, 'RightOption');
                                    }
                                    else if(bigMap[i][robotObject.col].bouncerState == 1)
                                    {
                                        return destinationWithPowers(robotObject, 'LeftOption');
                                    }
                                    break;
                                }
                                else if(i != 6)
                                {
                                    if(bigMap[i + 1][robotObject.col].hasRobot)
                                    {return [i, robotObject.col];}
                                }
                                else{
                                    return [6, robotObject.col];
                                }
                            }
                        }
                        else if(robotObject.row  != 15)
                        {
                            if(!bigMap[robotObject.row + 1][robotObject.col].hasRobot)
                            { 
                                for(i = robotObject.row + 1; i <= 15; i++)
                                {
                                    if(bigMap[i][robotObject.col].bouncerState != 2 && robotObject.color != bigMap[i][robotObject.col].bouncerColor)
                                    {
                                        robotObject.setRow(i);
                                        if(bigMap[i][robotObject.col].bouncerState == 0)
                                        {
                                            return destinationWithPowers(robotObject, 'RightOption');
                                        }
                                        else if(bigMap[i][robotObject.col].bouncerState == 1)
                                        {
                                            return destinationWithPowers(robotObject, 'LeftOption');
                                        }
                                        break;
                                    }
                                    else if(i != 15)
                                    {
                                        if(bigMap[i + 1][robotObject.col].hasRobot)
                                        {return [i, robotObject.col];}
                                    }
                                    else{
                                        return [15, robotObject.col];
                                    }
                                }
                            }
                        }
                    }
                    
                    if(robotObject.getColor() == 'Blue')
                    {
                        robotObject.setPow(false);
                        document.getElementById("powerOptionBlue").style.backgroundColor = 'lightgray';
                        if(robotObject.row + 4 <= 15 && !redB)
                        {
                            if(!((robotObject.row + 4 == 7 || robotObject.row + 4 == 8) && (robotObject.col == 7 || robotObject.col == 8 )))
                            {
                                if(!bigMap[robotObject.row + 4][robotObject.col].hasRobot)
                                {
                                    return [robotObject.row + 4, robotObject.col];
                                }
                            }
                        }
                        else if(robotObject.row + 4 <= 15 )
                        {
                            verifyBlueGroup('DownOption');
                        }
                    }

                    if(robotObject.getColor() == 'Yellow')
                    {
                        if((robotObject.col == 7 || robotObject.col == 8) && !bigMap[robotObject.row + 1][robotObject.col].hasRobot && robotObject.row <= 6)
                        {
                            for(i = robotObject.row; i <= 6; i++)
                            {
                                if(bigMap[i][robotObject.col].bouncerState != 2 && robotObject.color != bigMap[i][robotObject.col].bouncerColor && robotObject.row != i)
                                {
                                    robotObject.setRow(i);
                                    if(bigMap[i][robotObject.col].bouncerState == 0)
                                    {
                                        return destinationWithPowers(robotObject, 'RightOption');
                                    }
                                    else if(bigMap[i][robotObject.col].bouncerState == 1)
                                    {
                                        return destinationWithPowers(robotObject, 'LeftOption');
                                    }
                                    break;
                                }
                                else if (bigMap[i][robotObject.col].D && i != 6)
                                {
                                    robotObject.setRow(i + 1);
                                    robotObject.setPow(false);
                                    document.getElementById("powerOptionYellow").style.backgroundColor = 'lightgray';
                                    return isStoppingLocation(robotObject, 'DownOption');
                                }
                                else if(i != 6)
                                {
                                    if(bigMap[i + 1][robotObject.col].hasRobot)
                                    {return [i, robotObject.col];}
                                }
                                else{
                                    return [6, robotObject.col];
                                }
                            }
                        }
                        else if(robotObject.row  != 15)
                        {
                            if(!bigMap[robotObject.row + 1][robotObject.col].hasRobot)
                            { 
                                for(i = robotObject.row; i <= 15; i++)
                                {
                                    if(bigMap[i][robotObject.col].bouncerState != 2 && robotObject.color != bigMap[i][robotObject.col].bouncerColor && robotObject.row != i)
                                    {
                                        robotObject.setRow(i);
                                        if(bigMap[i][robotObject.col].bouncerState == 0)
                                        {
                                            return destinationWithPowers(robotObject, 'RightOption');
                                        }
                                        else if(bigMap[i][robotObject.col].bouncerState == 1)
                                        {
                                            return destinationWithPowers(robotObject, 'LeftOption');
                                        }
                                    }
                                    else if (bigMap[i][robotObject.col].D && i != 15)
                                    {
                                        robotObject.setRow(i + 1);
                                        robotObject.setPow(false);
                                        document.getElementById("powerOptionYellow").style.backgroundColor = 'lightgray';
                                        return isStoppingLocation(robotObject, 'DownOption');
                                    }
                                    else if(i != 15)
                                    {
                                        if(bigMap[i + 1][robotObject.col].hasRobot)
                                        {return [i, robotObject.col];}
                                    }
                                    else{
                                        return [15, robotObject.col];
                                    }
                                }
                            }
                        }
                    }

                    if(robotObject.getColor() == 'LightGreeen')
                    {
                        moves--;
                        return [robotObject.row + 1, robotObject.col];
                    }

                    if(robotObject.getColor() == 'Red')
                    {//verifyBlueGroup(option);
                        verifyDistNormal(option);
                    }   
                }
            }     
            if(option == 'LeftOption')
            {
                if(robotObject.col != 0)
                {
                    if(robotObject.getColor() == 'Grey')
                    {
                        if((robotObject.row == 7 || robotObject.row == 8) && !bigMap[robotObject.row][robotObject.col - 1].hasRobot && robotObject.col >= 9)
                        {
                            for(i = robotObject.col - 1; i >= 9; i--)
                            {
                                if(bigMap[robotObject.row][i].bouncerState != 2 && robotObject.color != bigMap[robotObject.row][i].bouncerColor)
                                {
                                    robotObject.setCol(i);
                                    if(bigMap[robotObject.row][i].bouncerState == 0)
                                    {
                                        return destinationWithPowers(robotObject, 'UpOption');
                                    }
                                    else if(bigMap[robotObject.row][i].bouncerState == 1)
                                    {
                                        return destinationWithPowers(robotObject, 'DownOption');
                                    }
                                    break;
                                }
                                else if(i != 9)
                                {
                                    if(bigMap[robotObject.row][i - 1].hasRobot)
                                    {return [robotObject.row, i];}
                                }
                                else{
                                    return [robotObject.row, 9];
                                }
                            }
                        }
                        else if(!bigMap[robotObject.row][robotObject.col - 1].hasRobot){
                            
                            for(i = robotObject.col - 1; i >= 0; i--)
                            {
                                if(bigMap[robotObject.row][i].bouncerState != 2 && robotObject.color != bigMap[robotObject.row][i].bouncerColor)
                                {
                                    robotObject.setCol(i);
                                    if(bigMap[robotObject.row][i].bouncerState == 0)
                                    {
                                        return destinationWithPowers(robotObject, 'UpOption');
                                    }
                                    else if(bigMap[robotObject.row][i].bouncerState == 1)
                                    {
                                        return destinationWithPowers(robotObject, 'DownOption');
                                    }
                                    break;
                                }
                                else if(i != 0)
                                {   
                                    if(bigMap[robotObject.row][i - 1].hasRobot)
                                    {return [robotObject.row, i];}
                                }
                                else{
                                    return [robotObject.row, 0];
                                }
                            }
                        }
                    }
                
                    if(robotObject.getColor() == 'Blue')
                    {
                        robotObject.setPow(false);
                        document.getElementById("powerOptionBlue").style.backgroundColor = 'lightgray';
                        if(robotObject.col - 4 >= 0 && !redB) 
                        {
                            if(!((robotObject.col - 4 == 7 || robotObject.col - 4 == 8 ) && (robotObject.row == 7 || robotObject.row == 8 )))
                            {                            
                                if(!bigMap[robotObject.row][robotObject.col - 4].hasRobot)
                                {
                                    return [robotObject.row, robotObject.col - 4];
                                }
                            }
                        }else if(robotObject.col - 4 >= 0)
                        {
                            verifyBlueGroup('LeftOption');
                        }
                    }

                    if(robotObject.getColor() == 'Yellow')
                    {
                        if((robotObject.row == 7 || robotObject.row == 8) && !bigMap[robotObject.row][robotObject.col - 1].hasRobot && robotObject.col >= 9)
                        {
                            for(i = robotObject.col; i >= 9; i--)
                            {
                                if(bigMap[robotObject.row][i].bouncerState != 2 && robotObject.color != bigMap[robotObject.row][i].bouncerColor && robotObject.col != i)
                                {
                                    robotObject.setCol(i);
                                    if(bigMap[robotObject.row][i].bouncerState == 0)
                                    {
                                        return destinationWithPowers(robotObject, 'UpOption');
                                    }
                                    else if(bigMap[robotObject.row][i].bouncerState == 1)
                                    {
                                        return destinationWithPowers(robotObject, 'DownOption');
                                    }
                                }
                                else if (bigMap[robotObject.row][i].L && i != 9)
                                {
                                    robotObject.setCol(i - 1);
                                    robotObject.setPow(false);
                                    document.getElementById("powerOptionYellow").style.backgroundColor = 'lightgray';
                                    return isStoppingLocation(robotObject, 'LeftOption');
                                }
                                else if(i != 9)
                                {
                                    if(bigMap[robotObject.row][i - 1].hasRobot)
                                    {return [robotObject.row, i];}
                                }
                                else{
                                    return [robotObject.row, 9];
                                }
                            }
                        }
                        else if(!bigMap[robotObject.row][robotObject.col - 1].hasRobot){
                            
                            for(i = robotObject.col; i >= 0; i--)
                            {
                                if(bigMap[robotObject.row][i].bouncerState != 2 && robotObject.color != bigMap[robotObject.row][i].bouncerColor && robotObject.col != i)
                                {
                                    robotObject.setCol(i);
                                    if(bigMap[robotObject.row][i].bouncerState == 0)
                                    {
                                        return destinationWithPowers(robotObject, 'UpOption');
                                    }
                                    else if(bigMap[robotObject.row][i].bouncerState == 1)
                                    {
                                        return destinationWithPowers(robotObject, 'DownOption');
                                    }
                                }
                                else if (bigMap[robotObject.row][i].L && i != 0)
                                {
                                    robotObject.setCol(i - 1);
                                    robotObject.setPow(false);
                                    document.getElementById("powerOptionYellow").style.backgroundColor = 'lightgray';
                                    return isStoppingLocation(robotObject, 'LeftOption');
                                }
                                else if(i != 0)
                                {                                    
                                    if(bigMap[robotObject.row][i - 1].hasRobot)
                                    {return [robotObject.row, i];}
                                }
                                else{
                                    return [robotObject.row, 0];
                                }
                            }
                        }
                    }

                    if(robotObject.getColor() == 'LightGreeen')
                    {
                        moves--;
                        return [robotObject.row, robotObject.col - 1];
                    }

                    if(robotObject.getColor() == 'Red')
                    {
                        //verifyBlueGroup(option);
                        verifyDistNormal(option);
                    }
                }
            }
            if(option == 'RightOption')
            {
                if(robotObject.col != 15)
                {
                    if(robotObject.getColor() == 'Grey')
                    {
                        if((robotObject.row == 7 || robotObject.row == 8) && !bigMap[robotObject.row][robotObject.col + 1].hasRobot && robotObject.col <= 6)
                        {
                            for(i = robotObject.col + 1; i <= 6; i++)
                            {
                                if(bigMap[robotObject.row][i].bouncerState != 2 && robotObject.color != bigMap[robotObject.row][i].bouncerColor)
                                {
                                    robotObject.setCol(i);
                                    if(bigMap[robotObject.row][i].bouncerState == 0)
                                    {
                                        return destinationWithPowers(robotObject, 'UpOption');
                                    }
                                    else if(bigMap[robotObject.row][i].bouncerState == 1)
                                    {
                                        return destinationWithPowers(robotObject, 'DownOption');
                                    }
                                }
                                else if(i != 6)
                                {
                                    if(bigMap[robotObject.row][i + 1].hasRobot)
                                    {return [robotObject.row, i];}
                                }
                                else{
                                    return [robotObject.row, 6];
                                }
                            }
                        }
                        else if(!bigMap[robotObject.row ][robotObject.col + 1].hasRobot)
                        {
                            for(i = robotObject.col + 1; i <= 15; i++)
                            {
                                if(bigMap[robotObject.row][i].bouncerState != 2 && robotObject.color != bigMap[robotObject.row][i].bouncerColor)
                                {
                                    robotObject.setCol(i);
                                    if(bigMap[robotObject.row][i].bouncerState == 0)
                                    {
                                        return destinationWithPowers(robotObject, 'DownOption');
                                    }
                                    else if(bigMap[robotObject.row][i].bouncerState == 1)
                                    {
                                        return destinationWithPowers(robotObject, 'UpOption');
                                    }
                                }
                                else if(i != 15)
                                {
                                    if(bigMap[robotObject.row][i + 1].hasRobot)
                                    {return [robotObject.row, i];}
                                }
                                else{
                                    return [robotObject.row, 15];
                                }
                            }   
                        }
                    }
                    
                    if(robotObject.getColor() == 'Blue')
                    {
                        robotObject.setPow(false);
                        document.getElementById("powerOptionBlue").style.backgroundColor = 'lightgray';
                        if(robotObject.col + 4 <= 15 && !redB)
                        {
                            if(!((robotObject.col + 4 == 7 || robotObject.col + 4 == 8 ) && (robotObject.row == 7 || robotObject.row == 8 )))
                            {                            
                                if(!bigMap[robotObject.row][robotObject.col + 4].hasRobot)
                                {
                                    
                                    return [robotObject.row, robotObject.col + 4];
                                }
                            }
                        }
                        else if(robotObject.col + 4 <= 15)
                        {
                            verifyBlueGroup('RightOption');
                        }
                    }
                    
                    if(robotObject.getColor() == 'Yellow')
                    {
                        if((robotObject.row == 7 || robotObject.row == 8) && !bigMap[robotObject.row][robotObject.col + 1].hasRobot && robotObject.col <= 6)
                        {
                            for(i = robotObject.col; i <= 6; i++)
                            {
                                if(bigMap[robotObject.row][i].bouncerState != 2 && robotObject.color != bigMap[robotObject.row][i].bouncerColor && robotObject.col != i)
                                {
                                    robotObject.setCol(i);
                                    if(bigMap[robotObject.row][i].bouncerState == 0)
                                    {
                                        return destinationWithPowers(robotObject, 'DownOption');
                                    }
                                    else if(bigMap[robotObject.row][i].bouncerState == 1)
                                    {
                                        return destinationWithPowers(robotObject, 'UpOption');
                                    }
                                }
                                else if (bigMap[robotObject.row][i].R && i != 6)
                                {
                                    robotObject.setCol(i + 1);
                                    robotObject.setPow(false);
                                    document.getElementById("powerOptionYellow").style.backgroundColor = 'lightgray';
                                    return isStoppingLocation(robotObject, 'RightOption');
                                }
                                else if(i != 6)
                                {
                                    if(bigMap[robotObject.row][i + 1].hasRobot)
                                    {return [robotObject.row, i];}
                                }
                                else{
                                    return [robotObject.row, 6];
                                }
                            }
                        }
                        else if(!bigMap[robotObject.row ][robotObject.col + 1].hasRobot)
                        {
                            for(i = robotObject.col; i <= 15; i++)
                            {
                                if(bigMap[robotObject.row][i].bouncerState != 2 && robotObject.color != bigMap[robotObject.row][i].bouncerColor && robotObject.col != i)
                                {
                                    robotObject.setCol(i);
                                    if(bigMap[robotObject.row][i].bouncerState == 0)
                                    {
                                        return destinationWithPowers(robotObject, 'DownOption');
                                    }
                                    else if(bigMap[robotObject.row][i].bouncerState == 1)
                                    {
                                        return destinationWithPowers(robotObject, 'UpOption');
                                    }
                                }
                                else if (bigMap[robotObject.row][i].R && i != 15)
                                {
                                    robotObject.setCol(i + 1);
                                    robotObject.setPow(false);
                                    document.getElementById("powerOptionYellow").style.backgroundColor = 'lightgray';
                                    return isStoppingLocation(robotObject, 'RightOption');
                                }
                                else if(i != 15)
                                {
                                    if(bigMap[robotObject.row][i + 1].hasRobot)
                                    {return [robotObject.row, i];}
                                }
                                else{
                                    return [robotObject.row, 15];
                                }
                            }   
                        }
                    }
                    
                    if(robotObject.getColor() == 'LightGreeen')
                    {
                        moves--;
                        return [robotObject.row, robotObject.col + 1];
                    }
                    
                    if(robotObject.getColor() == 'Red')
                    {//verifyBlueGroup(option);
                        verifyDistNormal(option);
                    }
                }
            }
            if(robotObject.getColor() == 'Blue')
            {
                document.getElementById("powerOptionBlue").style.backgroundColor = 'lightgray';
            }
            if(robotObject.getColor() == 'Yellow')
            {
                document.getElementById("powerOptionYellow").style.backgroundColor = 'lightgray';
            }
            for(i=1;i<robotMap.length;i++){if(robotMap[i].color != "LightGreeen"){robotMap[i].pow = false;}}
            robotMap[4].pow = true;
            return [robotObject.row, robotObject.col];
        }


        function insureRobots()
        {
            for(i = 0; i < 16; i++)
            {
                for(j=0; j < 16; j++)
                {
                    if(bigMap[i][j].hasRobot)
                    {
                        counter = 0;
                        for(k = 0, counter = 0; k < robotMap.length; k++)
                        {
                            
                            if(robotMap[k].row == i && robotMap[k].col == j)
                            {counter++}
                  
                        }
                        if(counter <= 0)
                        {
                            bigMap[i][j].setIsRobot(false);
                        }
                    }
                    else 
                    {
                        for(k = 0; k < robotMap.length; k++)
                        {
                            if(robotMap[k]. row == i && robotMap[k].col == j)
                            {
                                if(!bigMap[i][j].hasRobot)
                                {
                                    bigMap[i][j].setIsRobot(true);
                                }
                            }
                        }
                    }
                }
            }
        }


        function rememberScreen()
        {
            for(i = 0; i < 5; i++)
            {
               tempRobotPos[i] = [robotMap[i].row, robotMap[i].col]
            }
        }
        function newScreen()
        {
            tempRobotPos = [];
            for(t = 0; t < 5; t++)
            {
               tempRobotPos[t] = [robotMap[t].row, robotMap[t].col]
            }
            redB = false;
            redG = false;
            redGrey = false;
            redY = false;
            moveHistory = [];
            grappledRobots = [robotMap[4]];
            resetHolo();
        }
        function resetScreen()
        {
            for(p = 0; p < 5; p++)
            {
               moveRobot(tempRobotPos[p][0],tempRobotPos[p][1], robotMap[p].getColor())
            }
            redB = false;
            redG = false;
            redGrey = false;
            redY = false;
            moveHistory = [];
            grappledRobots = [robotMap[4]];
            insureRobots();
            resetHolo();
        }
        function resetHolo()
        {
            if(robotMap.length == 6)
            {
                const robots = document.querySelectorAll('.robot');
                let robotToMove = null;
                document.getElementById("powerOptionGreen").style.backgroundColor ='lightgray';
                robots.forEach((robot) => {
                    if (robot.src.includes('LightGreeen')) {
                        robotToMove = robot;   
                    }
                });
                bigMap[robotMap[5].row][robotMap[5].col].setIsRobot(false);
                robotToMove.parentElement.removeChild(robotToMove);
                robotMap.splice(5, 1);
            }
        }


        function verifyBlueGroup(direction)
        {
            allGood = true;
            if(direction == 'UpOption')
            {
                for(i = 0; i < grappledRobots.length; i++)
                {
                    if(grappledRobots[i].row - 4 >= 0 && !bigMap[grappledRobots[i].row - 4][grappledRobots[i].col].hasRobot)
                    {
                        if(((grappledRobots[i].row - 4 == 7 || grappledRobots[i].row - 4 == 8) && (grappledRobots[i].col == 7 || grappledRobots[i].col == 8 )))
                        {
                            allGood = false;
                        }
                    }
                    else{
                        allGood = false;
                    }
                }
                console.log("Is it allGood? : " + allGood);
                if(allGood)
                {
                    moveHistory[moveHistory.length] = new move(0, 0, 0);
                    for(t = 0; t < grappledRobots.length; t++)
                    {
                        moveHistory[moveHistory.length] = new move(grappledRobots[t].row, grappledRobots[t].col, grappledRobots[t].getColor());
                        moveRobot(grappledRobots[t].row - 4,grappledRobots[t].col, grappledRobots[t].color);
                    }
                    moveHistory[moveHistory.length] = new move(0, 0, 0);
                }
            }
            if(direction == 'DownOption')
            {
                for(i = 0; i < grappledRobots.length; i++)
                {
                    if(grappledRobots[i].row + 4 <= 15 && !bigMap[grappledRobots[i].row + 4][grappledRobots[i].col].hasRobot)
                    {
                        if(((grappledRobots[i].row + 4 == 7 || grappledRobots[i].row + 4 == 8) && (grappledRobots[i].col == 7 || grappledRobots[i].col == 8 )))
                        {
                            allGood = false;
                        }
                    }
                    else{
                        allGood = false;
                    }
                }
                console.log("Is it allGood? : " + allGood);
                if(allGood)
                {
                    moveHistory[moveHistory.length] = new move(0, 0, 0);
                    for(t = 0; t < grappledRobots.length; t++)
                    {
                        moveHistory[moveHistory.length] = new move(grappledRobots[t].row, grappledRobots[t].col, grappledRobots[t].getColor());
                        moveRobot(grappledRobots[t].row + 4,grappledRobots[t].col, grappledRobots[t].color);
                    }
                    moveHistory[moveHistory.length] = new move(0, 0, 0);
                }
            }
            if(direction == 'LeftOption')
            {               
                for(i = 0; i < grappledRobots.length; i++)
                {
                    if(grappledRobots[i].col - 4 >= 0 && !bigMap[grappledRobots[i].row][grappledRobots[i].col - 4].hasRobot)
                    {
                        if(((grappledRobots[i].col - 4 == 7 || grappledRobots[i].col - 4 == 8 ) && (grappledRobots[i].row == 7 || grappledRobots[i].row == 8 )))
                        {
                            allGood = false;
                        }
                    }
                    else{
                        allGood = false;
                    }
                }
                console.log("Is it allGood? : " + allGood);
                if(allGood)
                {
                    moveHistory[moveHistory.length] = new move(0, 0, 0);
                    for(t = 0; t < grappledRobots.length; t++)
                    {
                        moveHistory[moveHistory.length] = new move(grappledRobots[t].row, grappledRobots[t].col, grappledRobots[t].getColor());
                        moveRobot(grappledRobots[t].row,grappledRobots[t].col - 4, grappledRobots[t].color);
                    }
                    moveHistory[moveHistory.length] = new move(0, 0, 0);
                }
            }
            if(direction == 'RightOption')
            {                 
                for(i = 0; i < grappledRobots.length; i++)
                {
                    if(grappledRobots[i].col + 4 <= 15 && !bigMap[grappledRobots[i].row][grappledRobots[i].col + 4].hasRobot)
                    {
                        if(((grappledRobots[i].col + 4 == 7 || grappledRobots[i].col + 4 == 8 ) && (grappledRobots[i].row == 7 || grappledRobots[i].row == 8 )))
                        {
                            allGood = false;
                        }
                    }
                    else{
                        allGood = false;
                    }
                }
                console.log("Is it allGood? : " + allGood); 
                if(allGood)
                {
                    moveHistory[moveHistory.length] = new move(0, 0, 0);
                    for(t = 0; t < grappledRobots.length; t++)
                    {
                        moveHistory[moveHistory.length] = new move(grappledRobots[t].row, grappledRobots[t].col, grappledRobots[t].getColor());
                        moveRobot(grappledRobots[t].row,grappledRobots[t].col + 4, grappledRobots[t].color);
                    }
                    moveHistory[moveHistory.length] = new move(0, 0, 0);
                }         
            } 
            return allGood;
        }


        function verifyDistNormal(direction)
        {//C'EST ICI QUON CHECK POUR LE BOUNCERRED
        //check si tu frappes un bouncer ou un mur avant. Si c'est bouncer lance cette fonct encore après avoir 
        //TODO set les positions au bouncer et ensuite si c'est mur tu fait juste return le nombre plus court et tous les faires avancer à cette distance
            smallest = 60;
            tempDir = direction;
            moved = false;
            for(i = 0; i < grappledRobots.length; i++)
            { 
                bigMap[grappledRobots[i].row][grappledRobots[i].col].setIsRobot(false);
            }
            if(direction == 'UpOption')
            { 
                for(r = 0; r < grappledRobots.length; r++)
                { 
                    a = dir(grappledRobots[r], direction);
                    if(Math.abs(a[0] - grappledRobots[r].row) <= smallest)
                    {
                        if((tempDir == direction && Math.abs(a[0] - grappledRobots[r].row) == smallest) || (Math.abs(a[0] - grappledRobots[r].row) < smallest))
                        {
                            tempDir = a[1];
                        }
                        smallest = Math.abs(a[0] - grappledRobots[r].row);
                    }                    
                }
                if(smallest > 0)
                {
                    moveHistory[moveHistory.length] = new move(0, 0, 0);
                    for(t = 0; t < grappledRobots.length; t++)
                    {
                        moveHistory[moveHistory.length] = new move(grappledRobots[t].row, grappledRobots[t].col, grappledRobots[t].getColor());
                        moveRobot(grappledRobots[t].row - smallest, grappledRobots[t].col, grappledRobots[t].color);
                    }
                    moveHistory[moveHistory.length] = new move(0, 0, 0);
                }
            }
            if(direction == 'DownOption')
            { 
                for(r = 0; r < grappledRobots.length; r++)
                { 
                    a = dir(grappledRobots[r], direction);
                    if(Math.abs(a[0] - grappledRobots[r].row) <= smallest)
                    {
                        if((tempDir == direction && Math.abs(a[0] - grappledRobots[r].row) == smallest) || (Math.abs(a[0] - grappledRobots[r].row) < smallest))
                        {
                            tempDir = a[1];
                        }
                        smallest = Math.abs(a[0] - grappledRobots[r].row);
                    }                    
                }
                if(smallest > 0)
                {
                    moveHistory[moveHistory.length] = new move(0, 0, 0);
                    for(t = 0; t < grappledRobots.length; t++)
                    {
                        moveHistory[moveHistory.length] = new move(grappledRobots[t].row, grappledRobots[t].col, grappledRobots[t].getColor());
                        moveRobot(grappledRobots[t].row + smallest, grappledRobots[t].col, grappledRobots[t].color);
                    }
                    moveHistory[moveHistory.length] = new move(0, 0, 0);
                }
            }
            if(direction == 'LeftOption')
            {                
                for(r = 0; r < grappledRobots.length; r++)
                { 
                    a = dir(grappledRobots[r], direction);
                    if(Math.abs(a[0] - grappledRobots[r].col) <= smallest)
                    {
                        if((tempDir == direction && Math.abs(a[0] - grappledRobots[r].col) == smallest) || ( Math.abs(a[0] - grappledRobots[r].col) < smallest))
                        {
                            tempDir = a[1];
                        }
                        smallest = Math.abs(a[0] - grappledRobots[r].col);
                    }                    
                }
                if(smallest > 0)
                {
                    moveHistory[moveHistory.length] = new move(0, 0, 0);
                    for(t = 0; t < grappledRobots.length; t++)
                    {
                        moveHistory[moveHistory.length] = new move(grappledRobots[t].row, grappledRobots[t].col, grappledRobots[t].getColor());
                        moveRobot(grappledRobots[t].row, grappledRobots[t].col - smallest, grappledRobots[t].color);
                    }
                    moveHistory[moveHistory.length] = new move(0, 0, 0);
                }
            }
            if(direction == 'RightOption')
            { 
                for(r = 0; r < grappledRobots.length; r++)
                { 
                    a = dir(grappledRobots[r], direction);
                    if(Math.abs(a[0] - grappledRobots[r].col) <= smallest)
                    {   
                        if((tempDir == direction && Math.abs(a[0] - grappledRobots[r].col) == smallest) || (Math.abs(a[0] - grappledRobots[r].col) < smallest))
                        {
                            tempDir = a[1];
                        }
                        smallest = Math.abs(a[0] - grappledRobots[r].col);
                    }                    
                }
                if(smallest > 0)
                {
                    moveHistory[moveHistory.length] = new move(0, 0, 0);
                    for(t = 0; t < grappledRobots.length; t++)
                    {
                        moveHistory[moveHistory.length] = new move(grappledRobots[t].row, grappledRobots[t].col, grappledRobots[t].getColor());
                        moveRobot(grappledRobots[t].row, grappledRobots[t].col + smallest, grappledRobots[t].color);
                    }
                    moveHistory[moveHistory.length] = new move(0, 0, 0);
                }
            }
            if(tempDir != direction)
            {   
                verifyDistNormal(tempDir);
            }
            insureRobots();
            if(smallest > 0 && tempDir == direction)
            {
                uptickMovesDisplay();
            }
        }



        //cette fonction vas déterminer la distance ou le robot devras atterir pet importe sa couleur et son pouvoir
        function dir(robotObject, direction)
        {
            if(robotMap[0] == robotObject && robotMap[0].pow)
            {
                if(direction == 'UpOption')
                {
                    if(robotObject.row != 0)
                    {
                        if((robotObject.col == 7 || robotObject.col == 8) && !bigMap[robotObject.row - 1][robotObject.col].hasRobot && robotObject.row >= 9)
                        {
                            for(i = robotObject.row - 1; i >= 9; i--)
                            {
                                if(bigMap[i][robotObject.col].bouncerState != 2 && robotObject.color != bigMap[i][robotObject.col].bouncerColor)
                                {
                                    if(bigMap[i][robotObject.col].bouncerState == 0)
                                    {
                                        return [i, 'LeftOption'];
                                    }
                                    else if(bigMap[i][robotObject.col].bouncerState == 1)
                                    {
                                        return [i, 'RightOption'];
                                    }
                                }
                                else if(i != 9)
                                {
                                    if(bigMap[i - 1][robotObject.col].hasRobot)
                                    {return [i, 'UpOption'];}
                                }
                                else{
                                    return [9, 'UpOption'];
                                }
                            }
                        }
                        else if(!bigMap[robotObject.row - 1][robotObject.col].hasRobot){
                            
                            for(i = robotObject.row - 1; i >= 0; i--)
                            {
                                if(bigMap[i][robotObject.col].bouncerState != 2 && robotObject.color != bigMap[i][robotObject.col].bouncerColor)
                                {
                                    if(bigMap[i][robotObject.col].bouncerState == 0)
                                    {
                                        return [i, 'LeftOption'];
                                    }
                                    else if(bigMap[i][robotObject.col].bouncerState == 1)
                                    {
                                        return [i, 'RightOption'];
                                    }
                                }
                                else if(i != 0)
                                {
                                    if(bigMap[i - 1][robotObject.col].hasRobot)
                                    {return [i, 'UpOption'];}
                                }
                                else{
                                    return [0, 'UpOption'];
                                }
                            }
                        }
                    }
                }
                if(direction == 'DownOption')
                {
                    if(robotObject.row != 15)
                    {
                        if((robotObject.col == 7 || robotObject.col == 8) && !bigMap[robotObject.row + 1][robotObject.col].hasRobot && robotObject.row <= 6)
                        {
                            for(i = robotObject.row + 1; i <= 6; i++)
                            {
                                if(bigMap[i][robotObject.col].bouncerState != 2 && robotObject.color != bigMap[i][robotObject.col].bouncerColor)
                                {
                                    if(bigMap[i][robotObject.col].bouncerState == 0)
                                    {
                                        return [i, 'RightOption'];
                                    }
                                    else if(bigMap[i][robotObject.col].bouncerState == 1)
                                    {
                                        return [i, 'LeftOption'];
                                    }
                                    break;
                                }
                                else if(i != 6)
                                {
                                    if(bigMap[i + 1][robotObject.col].hasRobot)
                                    {return [i, 'DownOption'];}
                                }
                                else{
                                    return [6, 'DownOption'];
                                }
                            }
                        }
                        else if(robotObject.row  != 15)
                        {
                            if(!bigMap[robotObject.row + 1][robotObject.col].hasRobot)
                            { 
                                for(i = robotObject.row + 1; i <= 15; i++)
                                {
                                    if(bigMap[i][robotObject.col].bouncerState != 2 && robotObject.color != bigMap[i][robotObject.col].bouncerColor)
                                    {
                                        if(bigMap[i][robotObject.col].bouncerState == 0)
                                        {
                                            return [i, 'RightOption'];
                                        }
                                        else if(bigMap[i][robotObject.col].bouncerState == 1)
                                        {
                                            return [i, 'LeftOption'];
                                        }
                                        break;
                                    }
                                    else if(i != 15)
                                    {
                                        if(bigMap[i + 1][robotObject.col].hasRobot)
                                        {return [i, 'DownOption'];}
                                    }
                                    else{
                                        return [15, 'DownOption'];
                                    }
                                }
                            }
                        } 
                    }
                }
                if(direction == 'LeftOption')
                {
                    if(robotObject.col != 0)
                    {
                        if((robotObject.row == 7 || robotObject.row == 8) && !bigMap[robotObject.row][robotObject.col - 1].hasRobot && robotObject.col >= 9)
                        {
                            for(i = robotObject.col - 1; i >= 9; i--)
                            {
                                if(bigMap[robotObject.row][i].bouncerState != 2 && robotObject.color != bigMap[robotObject.row][i].bouncerColor)
                                {
                                    if(bigMap[robotObject.row][i].bouncerState == 0)
                                    {
                                        return [i, 'UpOption'];
                                    }
                                    else if(bigMap[robotObject.row][i].bouncerState == 1)
                                    {
                                        return [i, 'DownOption'];
                                    }
                                }
                                else if(i != 9)
                                {
                                    if(bigMap[robotObject.row][i - 1].hasRobot)
                                    {return [i, 'LeftOption'];}
                                }
                                else{
                                    return [9, 'LeftOption'];
                                }
                            }
                        }
                        else if(!bigMap[robotObject.row][robotObject.col - 1].hasRobot){
                            
                            for(i = robotObject.col - 1; i >= 0; i--)
                            {
                                if(bigMap[robotObject.row][i].bouncerState != 2 && robotObject.color != bigMap[robotObject.row][i].bouncerColor)
                                {
                                    if(bigMap[robotObject.row][i].bouncerState == 0)
                                    {
                                        return [i, 'UpOption'];
                                    }
                                    else if(bigMap[robotObject.row][i].bouncerState == 1)
                                    {
                                        return [i, 'DownOption'];
                                    }
                                }
                                else if(i != 0)
                                {
                                    if(bigMap[robotObject.row][i - 1].hasRobot)
                                    {return [i, 'LeftOption'];}
                                }
                                else{
                                    return [0, 'LeftOption'];
                                }
                            }
                        }
                    }
                }
                if(direction == 'RightOption')
                {
                    if(robotObject.col != 15)
                    {
                        if((robotObject.row == 7 || robotObject.row == 8) && !bigMap[robotObject.row][robotObject.col + 1].hasRobot && robotObject.col <= 6)
                        {
                            for(i = robotObject.col + 1; i <= 6; i++)
                            {
                                if(bigMap[robotObject.row][i].bouncerState != 2 && robotObject.color != bigMap[robotObject.row][i].bouncerColor)
                                {
                                    if(bigMap[robotObject.row][i].bouncerState == 0)
                                    {
                                        return [i, 'DownOption'];
                                    }
                                    else if(bigMap[robotObject.row][i].bouncerState == 1)
                                    {
                                        return [i, 'UpOption'];
                                    }
                                }
                                else if(i != 6)
                                {
                                    if(bigMap[robotObject.row][i + 1].hasRobot)
                                    {return [i, 'RightOption'];}
                                }
                                else{
                                    return [6, 'RightOption'];
                                }
                            }
                        }
                        else if(!bigMap[robotObject.row ][robotObject.col + 1].hasRobot)
                        {
                            for(i = robotObject.col + 1; i <= 15; i++)
                            {
                                if(bigMap[robotObject.row][i].bouncerState != 2 && robotObject.color != bigMap[robotObject.row][i].bouncerColor)
                                {
                                    if(bigMap[robotObject.row][i].bouncerState == 0)
                                    {
                                        return [i, 'DownOption'];
                                    }
                                    else if(bigMap[robotObject.row][i].bouncerState == 1)
                                    {
                                        return [i, 'upOption'];
                                    }
                                }
                                else if(i != 15)
                                {
                                    if(bigMap[robotObject.row][i + 1].hasRobot)
                                    {return [i, 'RightOption'];}
                                }
                                else{
                                    return [15, 'RightOption'];
                                }
                            }   
                        }
                    }
                }
            }
            else if(robotMap[2] == robotObject && robotMap[2].pow)
            {
                if(direction == 'UpOption')
                {
                    if((robotObject.col == 7 || robotObject.col == 8) && !bigMap[robotObject.row - 1][robotObject.col].hasRobot && robotObject.row >= 9)
                    {
                        for(i = robotObject.row; i >= 9; i--)
                        {
                            if(bigMap[i][robotObject.col].bouncerState != 2 && robotObject.color != bigMap[i][robotObject.col].bouncerColor && robotObject.row != i)
                            {
                                if(bigMap[i][robotObject.col].bouncerState == 0)
                                {
                                    return [i, 'LeftOption'];
                                }
                                else if(bigMap[i][robotObject.col].bouncerState == 1)
                                {
                                    return [i, 'RightOption'];
                                }
                            }
                            else if (bigMap[i][robotObject.col].U && i != 9)
                            {
                                tempPos = robotObject.row;
                                robotObject.setRow(i - 1);
                                robotObject.setPow(false);
                                document.getElementById("powerOptionYellow").style.backgroundColor = 'lightgray';
                                a = isStoppingLocation(robotObject, 'UpOption')[0];
                                robotObject.setRow(tempPos);
                                return [a, 'UpOption'];
                            }
                            else if(i != 9)
                            {
                                if(bigMap[i - 1][robotObject.col].hasRobot)
                                {return [i, 'UpOption'];}
                            }
                            else{
                                return [9, 'UpOption'];
                            }
                        }
                    }
                    else if(!bigMap[robotObject.row - 1][robotObject.col].hasRobot)
                    {
                        
                        for(i = robotObject.row; i >= 0; i--)
                        {
                            if(bigMap[i][robotObject.col].bouncerState != 2 && robotObject.color != bigMap[i][robotObject.col].bouncerColor && robotObject.row != i)
                            {
                                if(bigMap[i][robotObject.col].bouncerState == 0)
                                {
                                    return [i, 'LeftOption'];
                                }
                                else if(bigMap[i][robotObject.col].bouncerState == 1)
                                {
                                    return [i, 'RightOption'];
                                }
                            }
                            else if (bigMap[i][robotObject.col].U && i != 0)
                            {
                                tempPos = robotObject.row;
                                robotObject.setRow(i - 1);
                                robotObject.setPow(false);
                                document.getElementById("powerOptionYellow").style.backgroundColor = 'lightgray';
                                a = isStoppingLocation(robotObject, 'UpOption')[0];
                                robotObject.setRow(tempPos);
                                return [a, 'UpOption'];
                            }
                            else if(i != 0)
                            {
                                if(bigMap[i - 1][robotObject.col].hasRobot)
                                {return [i, 'UpOption'];}
                            }
                            else{
                                return [0, 'UpOption'];
                            }
                        }
                    }
                }
                if(direction == 'DownOption')
                {
                    if((robotObject.col == 7 || robotObject.col == 8) && !bigMap[robotObject.row + 1][robotObject.col].hasRobot && robotObject.row <= 6)
                    {
                        for(i = robotObject.row; i <= 6; i++)
                        {
                            if(bigMap[i][robotObject.col].bouncerState != 2 && robotObject.color != bigMap[i][robotObject.col].bouncerColor && robotObject.row != i)
                            {
                                if(bigMap[i][robotObject.col].bouncerState == 0)
                                {
                                    return [i, 'RightOption'];
                                }
                                else if(bigMap[i][robotObject.col].bouncerState == 1)
                                {
                                    return [i, 'LeftOption'];
                                }
                            }
                            else if (bigMap[i][robotObject.col].D && i != 6)
                            {
                                tempPos = robotObject.row;
                                robotObject.setRow(i + 1);
                                robotObject.setPow(false);
                                document.getElementById("powerOptionYellow").style.backgroundColor = 'lightgray';
                                a = isStoppingLocation(robotObject, 'DownOption')[0];
                                robotObject.setRow(tempPos);
                                return [a, 'DownOption'];
                            }
                            else if(i != 6)
                            {
                                if(bigMap[i + 1][robotObject.col].hasRobot)
                                {return [i, 'DownOption'];}
                            }
                            else{
                                return [6, 'DownOption'];
                            }
                        }
                    }
                    else if(robotObject.row  != 15)
                    {
                        if(!bigMap[robotObject.row + 1][robotObject.col].hasRobot)
                        { 
                            for(i = robotObject.row; i <= 15; i++)
                            {
                                if(bigMap[i][robotObject.col].bouncerState != 2 && robotObject.color != bigMap[i][robotObject.col].bouncerColor && robotObject.row != i)
                                {
                                    if(bigMap[i][robotObject.col].bouncerState == 0)
                                    {
                                        return [i, 'RightOption'];
                                    }
                                    else if(bigMap[i][robotObject.col].bouncerState == 1)
                                    {
                                        return [i, 'LeftOption'];
                                    }
                                }
                                else if (bigMap[i][robotObject.col].D && i != 15)
                                {
                                    tempPos = robotObject.row;
                                    robotObject.setRow(i + 1);
                                    robotObject.setPow(false);
                                    document.getElementById("powerOptionYellow").style.backgroundColor = 'lightgray';
                                    a = isStoppingLocation(robotObject, 'DownOption')[0];
                                    robotObject.setRow(tempPos);
                                    return [a, 'DownOption'];
                                }
                                else if(i != 15)
                                {
                                    if(bigMap[i + 1][robotObject.col].hasRobot)
                                    {return [i, 'DownOption'];}
                                }
                                else{
                                    return [15, 'DownOption'];
                                }
                            }
                        }
                    }
                }
                if(direction == 'LeftOption')
                {
                    if((robotObject.row == 7 || robotObject.row == 8) && !bigMap[robotObject.row][robotObject.col - 1].hasRobot && robotObject.col >= 9)
                    {
                        for(i = robotObject.col; i >= 9; i--)
                        {
                            if(bigMap[robotObject.row][i].bouncerState != 2 && robotObject.color != bigMap[robotObject.row][i].bouncerColor && robotObject.col != i)
                            {
                                if(bigMap[robotObject.row][i].bouncerState == 0)
                                {
                                    return [i, 'UpOption'];
                                }
                                else if(bigMap[robotObject.row][i].bouncerState == 1)
                                {
                                    return [i, 'DownOption'];
                                }
                            }
                            else if (bigMap[robotObject.row][i].L && i != 9)
                            {
                                tempPos = robotObject.col;
                                robotObject.setCol(i - 1);
                                robotObject.setPow(false);
                                document.getElementById("powerOptionYellow").style.backgroundColor = 'lightgray';
                                a = isStoppingLocation(robotObject, 'LeftOption')[1];
                                robotObject.setCol(tempPos);
                                return [a,'LeftOption'];
                            }
                            else if(i != 9)
                            {
                                if(bigMap[robotObject.row][i - 1].hasRobot)
                                {return [i, 'LeftOption'];}
                            }
                            else{
                                return [9, 'LeftOption'];
                            }
                        }
                    }
                    else if(!bigMap[robotObject.row][robotObject.col - 1].hasRobot){
                        
                        for(i = robotObject.col; i >= 0; i--)
                        {
                            if(bigMap[robotObject.row][i].bouncerState != 2 && robotObject.color != bigMap[robotObject.row][i].bouncerColor && robotObject.col != i)
                            {
                                if(bigMap[robotObject.row][i].bouncerState == 0)
                                {
                                    return [i, 'UpOption'];
                                }
                                else if(bigMap[robotObject.row][i].bouncerState == 1)
                                {
                                    return [i, 'DownOption'];
                                }
                            }
                            else if (bigMap[robotObject.row][i].L && i != 0)
                            {
                                tempPos = robotObject.col;
                                robotObject.setCol(i - 1);
                                robotObject.setPow(false);
                                document.getElementById("powerOptionYellow").style.backgroundColor = 'lightgray';
                                a = isStoppingLocation(robotObject, 'LeftOption')[1];
                                robotObject.setCol(tempPos);
                                return [a,'LeftOption'];
                            }
                            else if(i != 0)
                            {                                    
                                if(bigMap[robotObject.row][i - 1].hasRobot)
                                {return [i, 'LeftOption'];}
                            }
                            else{
                                return [0, 'LeftOption'];
                            }
                        }
                    }
                }
                if(direction == 'RightOption')
                {
                    if((robotObject.row == 7 || robotObject.row == 8) && !bigMap[robotObject.row][robotObject.col + 1].hasRobot && robotObject.col <= 6)
                    {
                        for(i = robotObject.col; i <= 6; i++)
                        {
                            if(bigMap[robotObject.row][i].bouncerState != 2 && robotObject.color != bigMap[robotObject.row][i].bouncerColor && robotObject.col != i)
                            {
                                if(bigMap[robotObject.row][i].bouncerState == 0)
                                {
                                    return [i, 'DownOption'];
                                }
                                else if(bigMap[robotObject.row][i].bouncerState == 1)
                                {
                                    return [i, 'UpOption'];
                                }
                            }
                            else if (bigMap[robotObject.row][i].R && i != 6)
                            {
                                tempPos = robotObject.col;
                                robotObject.setCol(i + 1);
                                robotObject.setPow(false);
                                document.getElementById("powerOptionYellow").style.backgroundColor = 'lightgray';
                                a = isStoppingLocation(robotObject, 'RightOption')[1];
                                robotObject.setCol(tempPos);
                                return [a,'RightOption'];
                            }
                            else if(i != 6)
                            {
                                if(bigMap[robotObject.row][i + 1].hasRobot)
                                {return [i, 'RightOption'];}
                            }
                            else{
                                return [6, 'RightOption'];
                            }
                        }
                    }
                    else if(!bigMap[robotObject.row ][robotObject.col + 1].hasRobot)
                    {
                        for(i = robotObject.col; i <= 15; i++)
                        {
                            if(bigMap[robotObject.row][i].bouncerState != 2 && robotObject.color != bigMap[robotObject.row][i].bouncerColor && robotObject.col != i)
                            {
                                if(bigMap[robotObject.row][i].bouncerState == 0)
                                {
                                    return [i, 'DownOption'];
                                }
                                else if(bigMap[robotObject.row][i].bouncerState == 1)
                                {
                                    return [i, 'UpOption'];
                                }
                            }
                            else if (bigMap[robotObject.row][i].R && i != 15)
                            {
                                tempPos = robotObject.col;
                                robotObject.setCol(i + 1);
                                robotObject.setPow(false);
                                document.getElementById("powerOptionYellow").style.backgroundColor = 'lightgray';
                                a = isStoppingLocation(robotObject, 'RightOption')[1];
                                robotObject.setCol(tempPos);
                                return [a,'RightOption'];
                            }
                            else if(i != 15)
                            {
                                if(bigMap[robotObject.row][i + 1].hasRobot)
                                {return [i, 'RightOption'];}
                            }
                            else{
                                return [15, 'RightOption'];;
                            }
                        }   
                    }
                }
            }
            else
            {
                if(direction == 'UpOption')
                { 
                    if(!bigMap[robotObject.row][robotObject.col].U && !bigMap[robotObject.row - 1][robotObject.col].hasRobot)
                    {
                        for(i = robotObject.row - 1; i >= 0; i--)
                        {
                            if(bigMap[i][robotObject.col].bouncerState != 2 && robotObject.color != bigMap[i][robotObject.col].bouncerColor)
                            {
                                if(bigMap[i][robotObject.col].bouncerState == 0)
                                {
                                    return [i, 'LeftOption'];
                                }
                                else if(bigMap[i][robotObject.col].bouncerState == 1)
                                {
                                    return [i, 'RightOption'];
                                }
                            }
                            else if (bigMap[i][robotObject.col].U)
                            {
                                return [i, 'UpOption'];
                            }
                            else if(i != 0)
                            {
                                if(bigMap[i - 1][robotObject.col].hasRobot)
                                {
                                    return [i, 'UpOption'];
                                }
                            }
                        }
                    }
                    return [robotObject.row, 'UpOption'];
                }
                if(direction == 'DownOption')
                { 
                    if(!bigMap[robotObject.row][robotObject.col].D && !bigMap[robotObject.row + 1][robotObject.col].hasRobot)
                    {
                        for(i = robotObject.row + 1; i <= 15; i++)
                        {
                            if(bigMap[i][robotObject.col].bouncerState != 2 && robotObject.color != bigMap[i][robotObject.col].bouncerColor)
                            {
                                if(bigMap[i][robotObject.col].bouncerState == 0)
                                {
                                    return [i, 'RightOption'];
                                }
                                else if(bigMap[i][robotObject.col].bouncerState == 1)
                                {
                                    return [i, 'LeftOption'];
                                }
                            }
                            else if (bigMap[i][robotObject.col].D)
                            {
                                return [i, 'DownOption'];
                            }
                            else if(i != 15)
                            {
                                if(bigMap[i + 1][robotObject.col].hasRobot)
                                {return [i, 'DownOption'];}
                            }
                        }
                        
                    }
                    return [robotObject.row, 'DownOption'];
                }
                if(direction == 'LeftOption')
                { 
                    if(!bigMap[robotObject.row][robotObject.col].L && !bigMap[robotObject.row ][robotObject.col - 1].hasRobot)
                    {
                        for(i = robotObject.col - 1; i >= 0; i--)
                        {
                            if(bigMap[robotObject.row][i].bouncerState != 2 && robotObject.color != bigMap[robotObject.row][i].bouncerColor)
                            {
                                if(bigMap[robotObject.row][i].bouncerState == 0)
                                {
                                    return [i, 'UpOption'];
                                }
                                else if(bigMap[robotObject.row][i].bouncerState == 1)
                                {
                                return [i,'DownOption'];
                                }
                            }
                            else if (bigMap[robotObject.row][i].L)
                            {
                                return [i, 'LeftOption'];
                            }
                            else if(i != 0)
                            {
                                if(bigMap[robotObject.row][i - 1].hasRobot)
                                {return [i, 'LeftOption'];}
                            }
                        }
                        
                    }
                    return [robotObject.col, 'LeftOption'];
                }
                if(direction == 'RightOption')
            { 
                if(!bigMap[robotObject.row][robotObject.col].R && !bigMap[robotObject.row ][robotObject.col + 1].hasRobot)
                {
                    for(i = robotObject.col + 1; i <= 15; i++)
                    {
                        if(bigMap[robotObject.row][i].bouncerState != 2 && robotObject.color != bigMap[robotObject.row][i].bouncerColor)
                        {
                            if(bigMap[robotObject.row][i].bouncerState == 0)
                            {
                                return [i,'DownOption'];
                            }
                            else if(bigMap[robotObject.row][i].bouncerState == 1)
                            {
                                return [i,'UpOption'];
                            }
                        }
                        else if (bigMap[robotObject.row][i].R)
                        {
                            return [i, 'RightOption'];
                        }
                        else if(i + 1 != 16)
                        {
                            if(bigMap[robotObject.row][i + 1].hasRobot)
                            {return [i, 'RightOption'];}
                        }
                    }
                    
                }
                return [robotObject.col, 'RightOption'];
            }
            }
        }


        
        // Select the checkbox container and buttons
        const checkboxContainer = document.getElementById('checkboxContainer');
        const returnButton = document.getElementById('returnButton');
        const cursedSettingsButton = document.getElementById('cursedSettingsButton');
        const greyBackgroundButton = document.getElementById('greyBackgroundButton');
        const playButton = document.getElementById('playButton'); // Select the PLAY button
        const reloadButton = document.getElementById('reloadButton'); // Select the reload button

        // Set initial background color
        let isGreyBackground = true; // Track the state of the background color
        document.body.style.backgroundColor = 'rgb(47,44,44)'; // Set the background color to dimgrey initially

        // Initially hide the checkboxes and return button
        checkboxContainer.style.display = 'none'; // Hide checkboxes
        gameContainer.style.display = 'none';
       
        let countdownInterval;
        let timeRemaining = 60; // 1 minute in seconds

        function startCountdown() {
            resetCountdown();
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }

            countdownInterval = setInterval(() => {
                if (timeRemaining > 0) {
                    timeRemaining--;
                    updateTimerDisplay();
                } else {
                    clearInterval(countdownInterval);
                }
            }, 1000);
        }

        function resetCountdown() {
            clearInterval(countdownInterval);
            timeRemaining = 60;
            updateTimerDisplay();
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(timeRemaining / 60);
            const seconds = timeRemaining % 60;
            document.getElementById("timerDisplay").textContent =
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        function uptickMovesDisplay() {
            moves++;
            document.getElementById("movesDisplay").textContent =
                `${moves.toString()}`;
        }


        function uptickPoint1Display() {
            if (mapRound % 2 == 1 && pointGiven == false) {
            p1p++;
            pointGiven = true;
            document.getElementById("p1p").textContent =
                `${p1p.toString()}`;}
        }
        function uptickPoint2Display() {
            if (mapRound % 2 == 1 && pointGiven == false) {
            p2p++;
            pointGiven = true;
            document.getElementById("p2p").textContent =
                `${p2p.toString()}`;}
        }
        function uptickPoint3Display() {
            if (mapRound % 2 == 1 && pointGiven == false) {
            p3p++;
            pointGiven = true;
            document.getElementById("p3p").textContent =
                `${p3p.toString()}`;}
        }
        function uptickPoint4Display() {
            if (mapRound % 2 == 1 && pointGiven == false) {
            p4p++;
            pointGiven = true;
            document.getElementById("p4p").textContent =
                `${p4p.toString()}`;}
        }


        document.getElementById("startTimer").onclick = startCountdown;
        document.getElementById("resetTimer").onclick = resetCountdown;

        // Add an event listener to the Cursed Settings button
        cursedSettingsButton.addEventListener('click', () => {
            // Show the checkboxes and return button
            checkboxContainer.style.display = 'flex'; // Show the checkboxes
            setTimeout(() => {
                checkboxContainer.style.opacity = 1; // Make visible
                checkboxContainer.style.pointerEvents = 'auto'; // Enable interaction
            }, 10); // Delay to ensure display property takes effect
            cursedSettingsButton.style.display = 'none'; // Hide Cursed Settings button
            playButton.style.display = 'none'; // Hide PLAY button
        });


        // Add an event listener to the Return button
        returnButton.addEventListener('click', () => {
            // Hide the checkboxes and return button
            checkboxContainer.style.opacity = 0; // Fade out
            checkboxContainer.style.pointerEvents = 'none'; // Prevent interaction
            setTimeout(() => {
                checkboxContainer.style.display = 'none'; // Hide after fade out
                cursedSettingsButton.style.display = 'block'; // Show Cursed Settings button
                playButton.style.display = 'block'; // Show PLAY button when returning
            }, 500); // Match the fade out duration
        });

        // Add an event listener to the PLAY button
        playButton.addEventListener('click', () => {
            // Hide both the Cursed Settings and PLAY buttons
            cursedSettingsButton.style.display = 'none'; // Hide Cursed Settings button
            playButton.style.display = 'none'; // Hide PLAY button
            gameContainer.style.display = 'flex';
            
            makeMap();
            generateRobots();
            rememberScreen();
            if(greyPower)
            {
                robotMap[0].setPow(true);
            }
            midCover();
            currentObjective = pickMapObjective();
            triggerNextObjective();
        });
        endRound.addEventListener('click', () => {
            if(pointGiven || mapRound == 0)
            {
                newScreen();            
                triggerMapHider();
                moves = -1;
                uptickMovesDisplay();
                unselectRobots();
                document.body.style.backgroundColor = 'rgb(47,44,44)';
                const label= document.querySelectorAll('span');
                label.forEach(label => {
                    label.style.color = 'white'; // Set label color
                });
            }
          });
        grey.addEventListener('click', () => {
            //////////////////////////////////////////////////////////////////////////////
        });
        point1.addEventListener('click', () => {
            uptickPoint1Display();
        });
        point2.addEventListener('click', () => {
            uptickPoint2Display();
        });
        point3.addEventListener('click', () => {
            uptickPoint3Display();
        });
        point4.addEventListener('click', () => {
            uptickPoint4Display();
        });
        
        function triggerMapHider() 
        {
            if (mapRound == 0) {
                const mapHid = document.createElement('div');
                mapHid.className = 'map-hid';

                // Set the dimensions, background color, and border of the mapHid div
                mapHid.style.width = '51%'; // Adjust the size as needed
                mapHid.style.height = '95%';
                mapHid.style.backgroundColor = 'rgb(47,44,44)';

                // Position the mapHid div on the screen (centered)
                mapHid.style.position = 'absolute';
                mapHid.style.top = '0%';
                mapHid.style.left = '0%';

                document.body.appendChild(mapHid); // Append the mapHid div to the document body
                
                mapHider[0] = mapHid; // Store the reference to the mapHid element
                mapRound++;
            } else if (mapRound % 2 == 1) {
                mapHider[0].style.display = 'none'; // Hide the mapHid div
                mapRound++;
                const p = document.querySelectorAll('p');
                    p.forEach(p => {
                        p.style.display = 'none'; // Set label color
                    });
                triggerNextObjective();
                midObj[0].style.display = 'flex'
            } else if (mapRound % 2 == 0) {
                mapHider[0].style.display = 'block'; // Show the mapHid div
                const p = document.querySelectorAll('p');
                    p.forEach(p => {
                        p.style.display = 'flex'; // Set label color
                    });
                mapRound++;
                pointGiven = false;
                midObj[0].style.display = 'none'
            }
            if (mapRound > 33) {
                displayGameOver();
            }
        }

        function displayGameOver() {
            // Create a full-screen overlay for the "GAME OVER" screen
            const gameOverOverlay = document.createElement('div');
            gameOverOverlay.style.position = 'fixed';
            gameOverOverlay.style.top = '0';
            gameOverOverlay.style.left = '0';
            gameOverOverlay.style.width = '100vw';
            gameOverOverlay.style.height = '100vh';
            gameOverOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
            gameOverOverlay.style.display = 'flex';
            gameOverOverlay.style.flexDirection = 'column';
            gameOverOverlay.style.alignItems = 'center';
            gameOverOverlay.style.justifyContent = 'center';
            gameOverOverlay.style.color = 'white';
            gameOverOverlay.style.fontSize = '5vw'; // Scale with viewport width
            gameOverOverlay.style.zIndex = '1000';

            // Add "GAME OVER" text
            const gameOverText = document.createElement('div');
            gameOverText.textContent = 'GAME OVER';
            gameOverText.style.marginBottom = '2vh'; // Scale margin with viewport height
            gameOverOverlay.appendChild(gameOverText);

            // Display each player's points
            const pointsContainer = document.createElement('div');
            pointsContainer.style.fontSize = '5vw'; // Scale with viewport width

            const playerScores = [
                { name: 'Player 1', points: p1p },
                { name: 'Player 2', points: p2p },
                { name: 'Player 3', points: p3p },
                { name: 'Player 4', points: p4p }
            ];

            playerScores.forEach(player => {
                const playerScore = document.createElement('div');
                playerScore.textContent = `${player.name}: ${player.points} points`;
                pointsContainer.appendChild(playerScore);
            });

            gameOverOverlay.appendChild(pointsContainer);

            // Add a reload button in the top-right corner
            const reloadButton = document.createElement('button');
            reloadButton.textContent = 'Reload';
            reloadButton.style.position = 'absolute';
            reloadButton.style.top = '4vh'; // Scale position with viewport height
            reloadButton.style.right = '2vw'; // Scale position with viewport width
            reloadButton.style.padding = '1vh 2vw'; // Scale padding
            reloadButton.style.fontSize = '2vw'; // Scale font size
            reloadButton.style.cursor = 'pointer';
            reloadButton.style.backgroundColor = '#ff4d4d';
            reloadButton.style.color = 'white';
            reloadButton.style.border = 'none';
            reloadButton.style.borderRadius = '0.5vw';

            reloadButton.addEventListener('click', () => {
                location.reload(); // Reload the page
            });

            gameOverOverlay.appendChild(reloadButton);

            // Append the overlay to the document body
            document.body.appendChild(gameOverOverlay);
        }


        function undo()
        {
            if (moveHistory.length > 0) {
                moveSet = moveHistory.pop();
                if(moveSet.color == 0)
                {
                    do
                    {
                        moveSet = moveHistory.pop();
                        if(moveSet.color != 0)
                        {
                            moveRobot(moveSet.row, moveSet.col,moveSet.color);
                        }
                    }
                    while(moveSet.color != 0)
                    moves--;
                    document.getElementById("movesDisplay").textContent =`${moves.toString()}`;
                }
                else if(moveSet.color == 1)
                {
                    //unGrapple
                    if(moveSet.col == 0)
                    {
                        if(moveSet.row == 'Blue')
                        {
                            unGrabbing = false;
                            redB = false;
                            grappledRobots.splice(grappledRobots.indexOf(robotMap[1]), 1);
                            console.log("redB = : " + redB);
                            flashButton("powerOptionRed", 'red');
                        }
                        if(moveSet.row == 'Green')
                        {
                            unGrabbing = false;
                            redG = false;
                            grappledRobots.splice(grappledRobots.indexOf(robotMap[3]), 1);
                            console.log("redG = : " + redG);
                            flashButton("powerOptionRed", 'red');
                        }
                        if(moveSet.row == 'Yellow')
                        {
                            unGrabbing = false;
                            redY = false;
                            grappledRobots.splice(grappledRobots.indexOf(robotMap[2]), 1);
                            console.log("redY = : " + redY);
                            flashButton("powerOptionRed", 'red');
                        }
                        if(moveSet.row == 'Grey')
                        {
                            unGrabbing = false;
                            redGrey = false;
                            grappledRobots.splice(grappledRobots.indexOf(robotMap[0]), 1);
                            console.log("redGrey = : " + redGrey);
                            flashButton("powerOptionRed", 'red');
                        }

                    }
                    //grapple
                    else if(moveSet.col == 1)
                    {
                        if(moveSet.row == 'Blue')
                        {
                            redB = true;
                            grappledRobots[grappledRobots.length] = robotMap[1];
                            console.log("redB = : " + redB);
                            flashButton("powerOptionRedGrab", 'red');
                        }
                        if(moveSet.row == 'Green')
                        {
                            redG = true;
                            grappledRobots[grappledRobots.length] = robotMap[3];
                            console.log("redG = : " + redG);
                            flashButton("powerOptionRedGrab", 'red');
                        }
                        if(moveSet.row == 'Yellow')
                        {
                            redY = true;
                            grappledRobots[grappledRobots.length] = robotMap[2];
                            console.log("redY = : " + redY);
                            flashButton("powerOptionRedGrab", 'red');
                        }
                        if(moveSet.row == 'Grey')
                        {
                            redGrey = true;
                            grappledRobots[grappledRobots.length] = robotMap[0];
                            console.log("redGrey = : " + redGrey);
                            flashButton("powerOptionRedGrab", 'red');
                        }
                    }
                    //undo();
                }
                else
                {
                    moveRobot(moveSet.row, moveSet.col,moveSet.color);
                    if(moveSet.color != 'LightGreeen')
                    {
                        moves--;
                        document.getElementById("movesDisplay").textContent =`${moves.toString()}`;
                    }
                    else if(robotMap[5].row == robotMap[3].row && robotMap[5].col == robotMap[3].col)
                    {
                        resetHolo();
                    }
                }
            }
        }




        //mov green, move blue to red, grapple blue, move green, ungrapple blue, move red, undo, undo(grapples blue to red and undoes green),

        undoOption.addEventListener('click', () => {
            undo();
        });

        function unselectRobots()
        {
            for(i=0;i<robotMap.length;i++)
            {
                robotMap[i].setIsSelected(false);
            }
        }

        function midCover() 
        {
            const midCov = document.createElement('div');
            midCov.style.width = '6.25%';
            midCov.style.height = '11%';
            midCov.style.backgroundColor = 'black';
            midCov.style.position = 'absolute';
            midCov.style.top = '41.5%';
            midCov.style.left = '22%';
            document.body.appendChild(midCov);
        }
          
        function triggerNextObjective() {
            
                

            obj.src = '/images/Rainbow.png'; // Replace with the actual path to your objective image

            if(currentObjective[mapObjectiveRound] == 1){obj.src = '/images/yellowTrig.jpg';}
            if(currentObjective[mapObjectiveRound] == 9){obj.src = '/images/redTrig.jpg';}
            if(currentObjective[mapObjectiveRound] == 6){obj.src = '/images/blueTrig.jpg';}
            if(currentObjective[mapObjectiveRound] == 13){obj.src = '/images/greenTrig.jpg';}
            if(currentObjective[mapObjectiveRound] == 2){obj.src = '/images/yellowSq.jpg';}
            if(currentObjective[mapObjectiveRound] == 10){obj.src = '/images/redSq.jpg';}
            if(currentObjective[mapObjectiveRound] == 8){obj.src = '/images/blueSq.jpg';}
            if(currentObjective[mapObjectiveRound] == 16){obj.src = '/images/greenSq.jpg';}
            if(currentObjective[mapObjectiveRound] == 3){obj.src = '/images/yellowHex.jpg';}
            if(currentObjective[mapObjectiveRound] == 11){obj.src = '/images/redHex.jpg';}
            if(currentObjective[mapObjectiveRound] == 7){obj.src = '/images/blueHex.jpg';}
            if(currentObjective[mapObjectiveRound] == 15){obj.src = '/images/greenHex.jpg';}
            if(currentObjective[mapObjectiveRound] == 4){obj.src = '/images/yellowCircle.jpg';}
            if(currentObjective[mapObjectiveRound] == 12){obj.src = '/images/redCircle.jpg';}
            if(currentObjective[mapObjectiveRound] == 5){obj.src = '/images/blueCircle.jpg';}
            if(currentObjective[mapObjectiveRound] == 14){obj.src = '/images/greenCircle.jpg';}
            mapObjectiveRound++;
            obj.alt = 'obj';
            obj.style.width = '6%';
            obj.style.height = '11%';
            obj.style.backgroundColor = 'black';
            obj.style.position = 'absolute';
            obj.style.top = '41%';
            obj.style.left = '21.9%';
            midObj[0] = obj;
            document.body.appendChild(obj);
        }

        

        // Toggle background color when the button is clicked
        greyBackgroundButton.addEventListener('click', () => {
            // Toggle the background color between dimgrey and white
            isGreyBackground = !isGreyBackground; // Toggle state
            document.body.style.backgroundColor = isGreyBackground ? 'rgb(47,44,44)' : 'white'; // Apply background color
            
            // Change the label text color based on the background color
            const labels = document.querySelectorAll('label');
            labels.forEach(label => {
                label.style.color = isGreyBackground ? 'lightgrey' : 'black'; // Set label color
            });
        });

        // Select all checkboxes
        const checkboxes = document.querySelectorAll('input[type="checkbox"]');

        // Loop through checkboxes and assign classes based on their names
        checkboxes.forEach(checkbox => {
            if (checkbox.name.includes("bigOption")) {
                checkbox.classList.add("big-checkbox");
            } else if (checkbox.name.includes("mediumOption")) {
                checkbox.classList.add("medium-checkbox");
            }
        });

        function flashButton(id, color) {
            // Select the button element
            const button = document.getElementById(id);

            // Define the colors for flashing
            const color1 = color;
            const color2 = 'lightgray';

            // Start flashing
            let isColor1 = true;
            const flashInterval = setInterval(() => {
                button.style.backgroundColor = isColor1 ? color1 : color2;
                isColor1 = !isColor1;
            }, 100); // Toggle color every 100 milliseconds

            // Stop flashing after 1 second
            setTimeout(() => {
                clearInterval(flashInterval);
                button.style.backgroundColor = color2; // Set to the original color
            }, 1000); // 1 second = 1000 milliseconds
        }

        // Select the big checkbox and all medium checkboxes
        const bigCheckbox = document.getElementById('bigCheckbox');
        const mediumCheckboxes = document.querySelectorAll('input[name="mediumOption"]');

        // Add an event listener to the big checkbox
        bigCheckbox.addEventListener('change', () => {
            mediumCheckboxes.forEach(checkbox => {
                checkbox.checked = bigCheckbox.checked; // Set medium checkboxes based on big checkbox state
                if(greyPower)
                {
                    greyPower = false;
                }
                else{
                    greyPower = true;
                }
            });
        });
        grey.addEventListener('change', () => {
            if(greyPower)
            {
                greyPower = false;
            }
            else{
                greyPower = true;
            }
            
        });

        // Hide the checkbox container initially
        checkboxContainer.style.opacity = 0; // Set opacity to 0 for fading effect

        // Add an event listener to the reload button
        //reloadButton.addEventListener('click', () => {
          //  location.reload(); // Reload the page
        //});


       

        // Function to rotate the array once (90 degrees)
        function rotateOnce(array) {
            const size = array.length;
            let rotatedArray = [];
            for (let i = 0; i < size; i++) {
                rotatedArray[i] = [];
                for (let j = 0; j < size; j++) {
                    rotatedArray[i][j] = array[size - j - 1][i];
                }
            }
            return rotatedArray;
        }

        // Function to rotate the array and output Tile objects
        function rotateArrayState(array, state) {
            const size = array.length;
            let finalArray = array; // Start with the original array

            // Rotate based on state
            if (state >= 2) {
                finalArray = rotateOnce(finalArray);
            }
            if (state >= 3) {
                finalArray = rotateOnce(finalArray);
            }
            if (state === 4) {
                finalArray = rotateOnce(finalArray);
            }

            // Create an array of Tile objects based on the final array
            let tileObjectsArray = [];
            for (let i = 0; i < finalArray.length; i++) {
                tileObjectsArray[i] = [];
                for (let j = 0; j < finalArray[i].length; j++) {
                    const [L, U, R, D, bouncerState,p ,bouncerColor, objective] = finalArray[i][j];
                    tileObjectsArray[i][j] = new Tile(L, U, R, D, bouncerState, state, bouncerColor, objective);
                }
            }
            
            return tileObjectsArray; // Return the array of Tile objects
        }
        function pickMapState() {
            // Initialize an array with numbers 1 to 4
            const options = [1, 2, 3, 4];
            const pickedNumbers = [];

            // Loop until all options have been picked
            while (options.length > 0) {
                // Generate a random index
                const randomIndex = Math.floor(Math.random() * options.length);
                
                // Pick the number at the random index
                const pickedNumber = options[randomIndex];
                
                // Remove the picked number from options
                options.splice(randomIndex, 1);
                
                // Add the picked number to the pickedNumbers array
                pickedNumbers.push(pickedNumber);
            }

            return pickedNumbers; // Return the array of picked numbers
        }
        function pickMapGroup(num) {
            const pickedNumbers = [];
            
            for (let i = 0; i < num; i++) {
                // Generate a random number between 1 and 4 (inclusive)
                const randomNumber = Math.floor(Math.random() * 4) + 1;
                pickedNumbers.push(randomNumber); // Add the random number to the array
            }

            return pickedNumbers; // Return the array of picked numbers
        }
        function pickMapObjective() {
            // Initialize an array with numbers 1 to 4
            const options = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17];
            const pickedNumbers = [];

            // Loop until all options have been picked
            while (options.length > 0) {
                // Generate a random index
                const randomIndex = Math.floor(Math.random() * options.length);
                
                // Pick the number at the random index
                const pickedNumber = options[randomIndex];
                
                // Remove the picked number from options
                options.splice(randomIndex, 1);
                
                // Add the picked number to the pickedNumbers array
                pickedNumbers.push(pickedNumber);
            }

            return pickedNumbers; // Return the array of picked numbers
        }       
        function makeFullMap()
        {
            state = pickMapState();
            num = pickMapGroup(4);
            map1 = rotateArrayState(tileMaps[state[0]-1][num[0]-1],1);
            map2 = rotateArrayState(tileMaps[state[1]-1][num[1]-1],2);
            map3 = rotateArrayState(tileMaps[state[2]-1][num[2]-1],3);
            map4 = rotateArrayState(tileMaps[state[3]-1][num[3]-1],4);
            return assembleMaps(map1,map2,map3,map4);
        }
        function assembleMaps(map1, map2, map3, map4)
        {
            fullMap = [];
            for(i=0;i<8;i++)
            {
                if(map1[i][7].R == true)
                {
                    map2[i][0].setL(true);
                }
                if(map2[i][0].L == true)
                {
                    map1[i][7].setR(true);
                }

                if(map1[7][i].D == true)
                {
                    map4[0][i].setU(true);
                }
                if(map4[0][i].U == true)
                {
                    map1[7][i].setD(true);
                }

                if(map2[7][i].D == true)
                {
                    map3[0][i].setU(true);
                }
                if(map3[0][i].U == true)
                {
                    map2[7][i].setD(true);
                }
                fullMap[i] = [map1[i][0],map1[i][1],map1[i][2],map1[i][3],map1[i][4],map1[i][5],map1[i][6],map1[i][7],
                map2[i][0],map2[i][1],map2[i][2],map2[i][3],map2[i][4],map2[i][5],map2[i][6],map2[i][7]];
            }
            for(i=8,j=0;i<16;i++,j++)
            {
                if(map4[j][7].R == true)
                {
                    map3[j][0].setL(true);
                }
                if(map3[j][0].L == true)
                {
                    map4[j][7].setR(true);
                }

                fullMap[i] = [map4[j][0],map4[j][1],map4[j][2],map4[j][3],map4[j][4],map4[j][5],map4[j][6],map4[j][7],
                map3[j][0],map3[j][1],map3[j][2],map3[j][3],map3[j][4],map3[j][5],map3[j][6],map3[j][7]];
            }
            return fullMap;
        }


        function makeBaseMap()
        {
            mapNum = [[[1,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18],[0,1,0,0,2,1,1,18]],
            [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
            [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
            [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
            [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
            [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18]],
            [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,1,2,1,1,18]],
            [[1,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,0,0,2,1,1,18],[0,0,1,0,2,1,1,18],[1,1,0,0,2,1,1,18]]];
            // const size = mapNum.length;
            // finalArray = mapNum;

            // Create an array of Tile objects based on the final array
            // let tileObjectsArray = [];
            // for (let i = 0; i < finalArray.length; i++) {
            //     tileObjectsArray[i] = [];
            //     for (let j = 0; j < finalArray[i].length; j++) {
            //         const [L, U, R, D, bouncerState, , bouncerColor, objective] = finalArray[i][j];
            //         tileObjectsArray[i][j] = new Tile(L, U, R, D, bouncerState, 1, bouncerColor, objective);
            //     }
            // }
            
            return mapNum;

        }

        //this function makes a list of all valid tiles a certain wallType can be on
        function getTileMapValidities(currentTileMap, wallType, code)
        {
            let validTileBox = [];
            for(i = 1; i < currentTileMap.length - 1; i++)
            {
                for(j = 1; j < currentTileMap.length - 1; j++)
                {
                    if(code == 0)
                    {
                        if(wallType.state == 0)
                        {
                            if(checkDown([i,j], currentTileMap) && checkRight([i,j], currentTileMap))
                            {
                                validTileBox[validTileBox.length] = [i, j];
                            }
                        }
                        else if(wallType.state == 1)
                        {
                            if(checkDown([i,j], currentTileMap) && checkLeft([i,j], currentTileMap))
                            {
                                validTileBox[validTileBox.length] = [i, j];
                            }
                        }
                        else if(wallType.state == 2)
                        {
                            if(checkUp([i,j], currentTileMap) && checkLeft([i,j], currentTileMap))
                            {
                                validTileBox[validTileBox.length] = [i, j];
                            }
                        }
                        else
                        {
                            if(checkUp([i,j], currentTileMap) && checkRight([i,j], currentTileMap))
                            {
                                validTileBox[validTileBox.length] = [i, j];
                            }
                        }
                    }
                    else if(code == 1)
                    {
                        if(!currentTileMap[i][j][1] && !currentTileMap[i][j][3] && !currentTileMap[i][j][0] && !currentTileMap[i][j][2])   
                        {
                            validTileBox[validTileBox.length] = [i, j];
                        }
                    }
                }
            }
            return validTileBox;
        }
        //tilePos : [row, col]
        //tileMaps[][]
        function checkUp(tilePos, tileMap)
        {
            if(tileMap[tilePos[0] - 1][tilePos[1]][0] || tileMap[tilePos[0] - 1][tilePos[1]][2])//the tile above left and right check
            {
                return false;
            }
            else if(tileMap[tilePos[0] - 1][tilePos[1] - 1][3]|| tileMap[tilePos[0] - 1][tilePos[1] + 1][3])
            {
                return false;
            }
            else
            {
                return true;
            }
        }
        function checkDown(tilePos, tileMap)
        {
            if(tileMap[tilePos[0] + 1][tilePos[1]][0] || tileMap[tilePos[0] + 1][tilePos[1]][2])//the tile above left and riht check
            {
                return false;
            }
            else if(tileMap[tilePos[0] + 1][tilePos[1] - 1][3] || tileMap[tilePos[0] + 1][tilePos[1] + 1][3])
            {
                return false;
            }
            else
            {
                return true;
            }
        }
        function checkLeft(tilePos, tileMap)
        {
            if(tileMap[tilePos[0]][tilePos[1] - 1][1] || tileMap[tilePos[0]][tilePos[1] - 1][3])//the tile left up and down check
            {
                return false;
            }
            else if(tileMap[tilePos[0] + 1][tilePos[1] - 1][2] || tileMap[tilePos[0] - 1][tilePos[1] - 1][2])
            {
                return false;
            }
            else
            {
                return true;
            }
        }
        function checkRight(tilePos, tileMap)
        {
            if(tileMap[tilePos[0]][tilePos[1] + 1][1] || tileMap[tilePos[0]][tilePos[1] + 1][3])//the tile left up and down check
            {
                return false;
            }
            else if(tileMap[tilePos[0] + 1][tilePos[1] + 1][2] || tileMap[tilePos[0] - 1][tilePos[1] + 1][2])
            {
                return false;
            }
            else
            {
                return true;
            }
        }

        function addSingleWalls(tileMap)
        {
            const pickedNumbers = [];

            // Generate a random number between 0 and 8 (inclusive)
            for (let index = 0; index < 2; index++) 
            {
                const randomNumber = Math.floor(Math.random() * 6) + 1;
                pickedNumbers[pickedNumbers.length] = randomNumber; // Add the random number to the array
            }
            
            tileMap[0][pickedNumbers[0]][2] = 1;
            tileMap[0][pickedNumbers[0] + 1][0] = 1;
            tileMap[pickedNumbers[1]][0][3] = 1;
            tileMap[pickedNumbers[1] + 1][0][1] = 1;
        }

        function addCorneredWalls(tileMap, wallkinds)
        {
            // Generate a random number between 0 and 8 (inclusive)
            for (let index = 0; index < wallkinds.length; index++) 
            {
                wall = new wallType(wallkinds[index]);
                validTiles = getTileMapValidities(tileMap, wall, 0);
                if(validTiles.length > 0)
                {
                    randomValidLocation = Math.floor(Math.random() * validTiles.length);
                    randomValidLocation = validTiles[randomValidLocation];
                    tileMap[randomValidLocation[0]][randomValidLocation[1]][0] = (wall.L);//TODO change the walls for 1 or 0 vals instead of bools so compatibility 
                    tileMap[randomValidLocation[0]][randomValidLocation[1]][1] = (wall.U);
                    tileMap[randomValidLocation[0]][randomValidLocation[1]][2] = (wall.R);
                    tileMap[randomValidLocation[0]][randomValidLocation[1]][3] = (wall.D);
                    if(wall.state - 1 == 0)
                    {
                        //if(randomValidLocation[0] + 1 < 8)
                        {tileMap[randomValidLocation[0] + 1][randomValidLocation[1]][1] = 1;}
                        //if(randomValidLocation[1] + 1 < 8)
                        {tileMap[randomValidLocation[0]][randomValidLocation[1] - 1][2] = 1;}
                    }else if(wall.state - 1 == 1)
                    {
                        //if(randomValidLocation[0] + 1 < 8)
                        {tileMap[randomValidLocation[0] - 1][randomValidLocation[1]][3] = 1;} 
                        tileMap[randomValidLocation[0]][randomValidLocation[1] - 1][2] = 1;
                    }else if(wall.state - 1 == 2)
                    {
                        tileMap[randomValidLocation[0] - 1][randomValidLocation[1]][3] = 1;
                        tileMap[randomValidLocation[0]][randomValidLocation[1] + 1][0] = 1;
                    }else if(wall.state - 1 == 3)
                    {
                        tileMap[randomValidLocation[0] - 1][randomValidLocation[1]][3] = 1;
                        //if(randomValidLocation[1] + 1 < 8)
                        {tileMap[randomValidLocation[0]][randomValidLocation[1]][0] = 1;}
                        
                    }

                    if(mapMakingObj.length > 0)
                    {
                        tileMap[randomValidLocation[0]][randomValidLocation[1]][7] == mapMakingObj.pop();
                    }
                    else
                    {
                        tileMap[randomValidLocation[0]][randomValidLocation[1]][7] == 18;
                    }
                }
                else
                {
                    // if(wallKinds[index] <= 3 && wallKinds[index] >= 1)
                    // {
                    //     wallKinds[index]--;
                    //     index--;
                    // }
                    // else
                    // {
                    //     wallKinds[index]++;//TODO this part isnt complete but ill see in the future
                    // }
                    // index--;
                    console.log("There wasn't enough room to fit this type of piece in the generated map.");
                }
            }
        }

        function addBouncers(tileMap)
        {
            const numberOfBouncers = Math.floor(Math.random() * 2);
            let color = [];
            let bouncerState = [];
            let validTiles = [];
            for(i = 0; i < numberOfBouncers; i++)
            {
                color[color.length] = bColor(Math.floor(Math.random() * 4) + 1);
                bouncerState[bouncerState.length] = Math.floor(Math.random() * 1);
                validTiles = getTileMapValidities(tileMap, new wallType(1), 1);
            }
            if(validTiles.length > 0)
            {
                for(i = 0; i < numberOfBouncers; i++)
                {
                    randomValidLocation = Math.floor(Math.random() * validTiles.length);
                    randomValidLocation = validTiles[randomValidLocation];
                    tileMap[randomValidLocation[0], randomValidLocation[1]][6] = (color[i]);
                    tileMap[randomValidLocation[0], randomValidLocation[1]][4] = (bouncerState[i]);
                }
            }
        }

        function bColor(num)
        {
            if(num == 1)
            {
                num = 'Blue';
            } else if(num == 2)
            {
                num = 'Green';
            }else if(num == 3)
            {
                num = 'Red';
            } else if(num == 4)
            {
                num = 'Yellow';
            }
            return num;
        }

       
        function makeGenFullMap()
        {
            mapOrder = pickMapState();
            maps = [];
            maps[0] = generateMap(5);
            maps[1] = generateMap(4);
            maps[2] = (generateMap(4));
            maps[3] = (generateMap(4));

            state = pickMapState();
            map1 = rotateArrayState(maps[state[0]-1],1);
            map2 = rotateArrayState(maps[state[1]-1],2);
            map3 = rotateArrayState(maps[state[2]-1],3);
            map4 = rotateArrayState(maps[state[3]-1],4);
            return assembleMaps(map1,map2,map3,map4);
            //return assembleMaps(maps[mapOrder[0] - 1], maps[mapOrder[1] - 1], maps[mapOrder[2] - 1], maps[mapOrder[3] - 1]);
            return assembleMaps(generateMap(5), rotateOnce(generateMap(4)), generateMap(4), generateMap(4));
        }
        //first map has 5 objctives and minimum 12 walls, with at least 5 pockets where objectives can sit 
        //maps 2 to 4 have 8 to 12 walls and at least 4 pockets
        //map order is so that the first map doesnt always has five objectives
        //objOrder if so that the objectives are randomized
        //each 2 piece wall cant be connected except by a single overlapping wall and if so, no other walls can be close, ie at least a square dist away
        //there cant be two walls that follow each other  like so |___| it needs to be |_  _|
        //no walls can be |_ to the middle wall it can only be same sense (to avoid useless pockets)
        function generateMap(wallsAmount)
        {
            baseMap = makeBaseMap(); 
            wallKinds = pickMapGroup(wallsAmount);//but if it cant fit, try all wallTypes in order
            addSingleWalls(baseMap);
            addCorneredWalls(baseMap, wallKinds);
            //addBouncers(baseMap);
            return baseMap;
        }

        
    </script>
</body>
</html>